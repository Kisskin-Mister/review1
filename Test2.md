### ООП
1. Что такое ООП? В чем его плюсы и минусы?

> Объектно-ориентированное программирование - метод проектирования программирования при котором вся логика строится вокруг объектов и классов, а не функций и логики

>ПЛЮСЫ:
>- Проще писать сложные приложения, благодаря тому, что все разбито по классам и объектам, небольшим относительно кодом в объектах, а программирование зачастую ориентировано на взаимоотношение этих объектов
>- Такие приложения просты в модификации
>- защита данных путем инкапсуляции
>- расширение кода путем наследования и полиморфизма
>- простая расширяемость проекта

>МИНУСЫ:
>- ООП требует больше памяти для реализации процессов
>- Требует большой объем теоретических знаний

2. Принципы ООП:

> - Инкапсуляция (защита данных модификаторами доступа)
> - Полиморфизм (переопределение и перегруз методов)
> - Наследование (наследование классов и интерфейсов)
> - 

3. Что такое наследование?

>Наследование - механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.

4. Что такое композиция?
5. Что такое агрегирование?

>Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».
>Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.

>Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция.
>В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.


6. Что такое инкапсуляция? примеры

> инкапсуляция - назначение полям, классам модификаторы доступа


7. Что такое полиморфизм? примеры

> Полиморфизм переводится как **Poly**(много) и **Morphism**(поведение)
> существует два вида полиморфизма:
> - динамический(переопределение)
> - статический(перегруз)


8. Ковариантность типа возвращаемого значения?

>Когда метод в подклассе имеет возвращаемый тип, который является производным от возвращаемого типа метода в суперклассе, то этот тип считается ковариантным.


9. Что такое конструктор?

> Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.

10. Что такое конструктор по умолчанию?

>Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый __«конструктор по умолчанию»__.

```java
public ClassName() {}
```

> Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.

11. Можно ли в классе вызвать один конструктор из другого? Как это сделать?

>Если в классе есть два конструктора, один из которых принимает параметры, а другой нет, то второй может вызвать первый с помощью ключевого слова `this`.
>Пример:
>
```java

public class App {
    public static void main(String[] args) {
        class ClassX {
            int x;
            public ClassX() { // Конструктор без параметров
                this(0); // Вызов конструктора с параметрами
            }
            public ClassX(int xValue) {
                x = xValue;
            }
        }

        class ClassXY extends ClassX {
            int y;
            public ClassXY(int xValue, int yValue) {
                super(xValue); // вызов родительского конструктора
                y = yValue;
            }
        }

        ClassX classX = new ClassX();
        System.out.println(classX.x); // => 0

        ClassXY classXY = new ClassXY(1, 2);
        System.out.println(classXY.x + classXY.y); // => 3
    }
}

```


12. Что такое коллизия?

>Коллизия в HashCode происходит, когда два разных значения имеют одинаковый хэш-код при использовании функции хэширования. Это может привести к тому, что разные элементы будут сохранены в одной и той же ячейке таблицы хешей, что может вызвать конфликты при поиске элементов.

### Модификаторы
1. Какие модификаторы доступа могут быть у класса:

>- `public` - метод доступен для всего пространства программ
>- `package privat` - доступ только в пределах пакета (ставится по умолчанию)
>- `private` - доступ внутри класса
>- `protected` - доступ внутри пакета и наследника

2. Перечислите все модификаторы доступа в порядке уменьшения закрытости, какую область видимости они имеют?

>![[Pasted image 20231022025729.png]]

3. Модификатор [[STATIC.JAVA|static]]

>`static` определяет переменную не к объекту, а к классу, поэтому, чтобы вызвать переменную static нужно обращаться к классу, а не к объекту.

4. Можно ли использовать статические методы в обычных? Наоборот? Почему?

> Статические методы можно использовать в обычных, однако наоборот нельзя

5. Все о пакетах

> Пакеты
> _Пакетом (пространством имен) в Java называется структура вложенных по какому-то признаку папок с размещенными в них классами (интерфейсами, перечислениями, аннотациями), необходимыми проекту._
> с точки зрения Java они будут храниться в следующем пакете (в качестве разделителя уже используется точка вместо слеша):

```
ru.topjava.startjava.calculator
```

> При этом в начале каждого из классов необходимо разместить строку, указывающую на его принадлежность к конкретному пакету, используя ключевое слово _package_ и имя пакета (точка с запятой в конце — обязательна):

```java
package ru.topjava.startjava.calculator;
```
> чтобы воспользоваться методами, к примеру, класса _Scanner_, следует перед объявлением класса прописать следующее:

```java
import java.util.Scanner;
```
### Классы. Методы

1. Что такое класс

> Класс — это, по сути, шаблон для объекта. Он определяет, как объект будет выглядеть и какими функциями обладать. Каждый объект является объектом какого-то класса.
> Класс – это шаблон или чертеж, который определяет, как будут выглядеть и вести себя объекты, созданные на основе этого класса. Классы состоят из полей (переменных) и методов (функций).


2. Что такое объект?

> Объект – это конкретный экземпляр класса. Объекты создаются с использованием оператора `new` и инициализируются с помощью конструктора класса.

3. Класс Object и класс Class

> все классы по умолчанию наследуются от класса Object
> В Java класс java.lang.Class - это встроенный класс, который представляет класс или интерфейс во время выполнения. Он содержит различные методы, которые предоставляют информацию о классе или интерфейсе, такие как его имя, суперкласс, интерфейсы, поля и методы.

4. Все методы класcа Object

>`toString` - возвращает строковое представление объекта
>`hashCode` и `equals` - используются для сравнения объектов
>`getClass` - возвращает объект описывающий текущий класс
>`finalize` - очищает мусор, вызывается автоматически
>`clone` - клонирование объекта

5. Анонимные классы

> Анонимные классы используют для реализации методов интерфейсов или абстрактных классов, не создавая новый класс

6. Область видимости всех классов

>Область видимости определяется не только модификаторами доступа, но и фигурными скобками `{}`, таким образом типы данных видны только внутри этого блока (за исключением случаев, когда это переменная класса, имеющая public или default(т.е. без модификаотора; видна в одном пакете) уровень доступа) и всех внутренних блоках.

7. Вложенные классы

> вложенный класс - класс внутри класса
> разделяют два типа :
> - статические вложенные классы
> - нестатические вложенные(внутренние)

> Зачем они нужны?
> по большей части, чтобы сохранить логику кода
> есть класс велосипед, внутри него есть руль, таким образом мы будем вызывать определенный руль велосипеда, который не будет жить своей жизнью

8. Instanseof vs getClass

>- `instanceof` проверяет, является ли ссылка на объект с левой стороны экземпляром типа с правой стороны или некоторым его подтипом.
>- `getClass()` == ... проверяет идентичность типов.
> То есть, если getClass() проверяет полную идентичность класса, то instanceof вернет true даже если объект будет всего лишь подтипом, что может дать нам большую гибкость при активном использовании полиморфизма.

>- **obj instanceof** Student позволяет проверить, является ли объект obj экземпляром класса Student или его подклассов. Это означает, что если obj является экземпляром класса, производного от Student, то условие также будет выполнено. Например, если у нас есть классы Person и Student, и класс Student наследуется от класса Person, то выражение obj instanceof Student вернет true как для объектов класса Student, так и для объектов класса Person, если они были созданы с использованием ключевого слова new для класса Student.
>- **getClass() == obj.getClass()** проверяет, является ли тип объекта obj точно таким же, как тип класса, в котором выполняется код. Если это условие истинно, это означает, что объект obj был создан с использованием ключевого слова new для этого класса (или его подкласса), и он не является объектом другого класса или его подкласса.

>Таким образом, если нам нужно проверить тип объекта без учета его подклассов, мы можем использовать getClass() == obj.getClass(). Использование instanceof подходит, когда мы хотим проверить, является ли объект экземпляром класса или его подкласса.

9. Что входит в сигнатуру метода?

```java
модификатор доступа, тип возвращаемого значения, имя метода(список параметров) { // тело метода }
```
10. Переопределение метода

> **Переопределение** **метода** (англ. Method **overriding**) — это возможность реализовать **метод** так, чтобы он имел идентичную сигнатуру с **методом** класса-предка, но предоставлял иное поведение, не вызывая коллизий при его использовании.

11. Перегрузка и переопределение

> перегруз - сигнатура схожа, но изменены входные параметры
> переопределение - полностью схожая сигнатура, тела разные(новая реализация метода)

12. Что можно делать при переопределении метода, а что нельзя?

>1. **У переопределенного метода должны быть те же аргументы, что и у метода родителя.**
>2. **У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.**
>3. **Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»**

13. Для чего нужна аннотация @Override?

>**Аннотация** @**Override** используется в **Java** для указания того, что поданнотированный метод является переопределенным методом из суперкласса. Это служит предупреждением для компилятора, чтобы он проверил, является ли этот метод действительно переопределением.

14. Может ли статический метод быть перегружен?
15. Будет ли работать переопределение статического метода?

> Статические методы могут быть перегруженны, однако не могут быть переопределены, если же произошло переопределение, то метод родителя перекрывает метод наследника

16. final  у метода

>помечает как финальную версию метода
>такой метод не может быть более переопределен

### equals/hashCode

1. Перегрузка методов `hashCode` и `equals`
 >перегрузка возможна, но тогда придется прописывать полностью реализацию метода с новыми параметрами
 
 2. Контракт между hashCode и equals()
>При переопределении метода `equals` разработчик должен придерживаться основных правил, определенных в спецификации языка Java.
> 
> - **Рефлексивность**
> для любого заданного значения `x`, выражение `x.equals(x)` должно возвращать `true`.  
> _Заданного_ — имеется в виду такого, что `x != null`
> - **Симметричность**
> для любых заданных значений `x` и `y`, `x.equals(y)` должно возвращать `true` только в том случае, когда `y.equals(x)` возвращает `true`.
> - **Транзитивность**
> для любых заданных значений `x`, `y` и `z`, если `x.equals(y)` возвращает `true` и `y.equals(z)` возвращает `true`, `x.equals(z)` должно вернуть значение `true`.- - - **Согласованность**
> для любых заданных значений `x` и `y` повторный вызов `x.equals(y)` будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
> - **Сравнение null**
> для любого заданного значения `x` вызов `x.equals(null)` должен возвращать `false`.

>Для реализации хэш-функции в спецификации языка определены следующие правила:
> 
> - вызов метода `hashCode` один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
> - вызов метода `hashCode` над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода `equals` для этих объектов возвращает `true`).
> - вызов метода `hashCode` над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.

3. Правила hashCode
>Хэш — это некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то момент времени. Это число используется в Java преимущественно в хэш-таблицах, таких как `HashMap`. При этом хэш-функция получения числа на основе объекта должна быть реализована таким образом, чтобы обеспечить относительно равномерное распределение элементов по хэш-таблице. А также минимизировать вероятность появления коллизий, когда по разным ключам функция вернет одинаковое значение.

4. Правила переопределения equals
>1. Проверить на равенство ссылки объектов `this` и параметра метода `o`.  
>     `if (this == o) return true;`
> 2. Проверить, определена ли ссылка `o`, т. е. является ли она `null`.  
>     Если в дальнейшем при сравнении типов объектов будет использоваться оператор `instanceof`, этот пункт можно пропустить, т. к. этот параметр возвращает `false` в данном случае `null instanceof Object`.
> 3. Сравнить типы объектов `this` и `o` с помощью оператора `instanceof` или метода `getClass()`, руководствуясь описанием выше и собственным чутьем.
> 4. Если метод `equals` переопределяется в подклассе, не забудьте сделать вызов `super.equals(o)`
> 5. Выполнить преобразование типа параметра `o` к требуемому классу.
> 6. Выполнить сравнение всех значимых полей объектов:
>     - для примитивных типов (кроме `float` и `double`), используя оператор ==
>     - для ссылочных полей необходимо вызвать их метод `equals`
>     - для массивов можно воспользоваться перебором по циклу, либо методом `Arrays.equals()`
>     - для типов `float` и `double` необходимо использовать методы сравнения соответствующих оберточных классов `Float.compare()` и `Double.compare()`
> 7. И, наконец, ответить на три вопроса: является ли реализованный метод симметричным? Транзитивным? Согласованным? Два других принципа (рефлексивность и определенность), как правило, выполняются автоматически.

### Абстрактные классы

1. Что такое абстрактный класс
> Класс в котором один или более метод без реализации, который нужно реализовать в классах наследниках

2. Может ли быть конструктор у абстрактного класса
> Может. Для всех тех задач, для чего конструктор используется в обычных классах-родителях, ведь не всегда абстрактный класс полностью абстрактный, так как может нести в себе некоторые поля и реализованные методы

3. Может ли быть абстрактный класс без абстрактных методов?
>нет, тогда это обычный класс

4. Указатели `this` `super`
>`this` представляет текущий экземпляр класса, в то время как `super` - текущий экземпляр родительского класса.
>это нестатические указатели потому в статик методах их юзать нельзя
>благодаря ним можно вызывать конструктор в конструкторе

### Интерфейсы

1. Что такое интерфейс?
> Интерфейс — это контракт, который реализуется в некотором классе. У интерфейса не может быть состояния, поэтому в нем нельзя использовать изменяемые поля экземпляра. В интерфейсе могут быть только неизменяемые final-поля.

2. Когда использовать интерфейс?
>1. **Абстракция**: Интерфейсы позволяют определить общий контракт между объектами, скрывая детали реализации.
> 2. **Множественное наследование**: Java не поддерживает множественное наследование классов, но позволяет классу реализовывать несколько интерфейсов.
> 3. **Повышение гибкости**: Использование интерфейсов делает код более гибким и масштабируемым, так как можно внести изменения в реализацию без изменения контракта.

3. Можно ли создать поля в Интерфейсе?
> можно, но они будут `final static`, то есть константами

4. Какие методы в интерфейсе могут иметь реализацию
> Методы с модификатором доступа `private` и `default`

5. Можно ли создать статик методы в интерфейсах?
> Можно. После 8-ой джавы. Статические методы похожи на дефолт методы, однако их в отличии от вторых нельзя переопределять в классе

6. Синтаксические отличия интерфейса от абстрактного класса
> - в абстрактном классе пишем `abstract class` в ИФ - `interface`
> - в ИФ все поля `static final`
> - ИФ расширяют`implements`, АК наследуют `extends`
> - ИФ наследует ИФ `extends`, АК расширяет ИФ `implements`

### Данные. ENUM. Native.Лямбда

1. Как реализовать свой Immutable тип данных?
> для этого нужно создать final класс
> все поля должны быть private  и final

2. Как реализованна неизменность String
> Строка хранится в массиве char[]

3. Где хранятся ссылки на объект, примитивы, объекты?
> в пулах в памяти Heap, хеш таблицах

4. Что такое позднее и раннее связывание?
> Раннее связывание - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода.
> 
> Позднее связывание - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова. В java это можно сделать при помощи рефлексии.

5. Что такое varargs? Какие есть ограничения при написании?
> Varargs — это аргументы переменной длины: фича, которая появилась еще в JDK5. Varargs позволяют нам создавать методы с произвольным количеством аргументов.

```java
int sum(int... numbers){ return Arrays.stream(numbers).sum(); }
```
1. Vararg аргумент (или же аргумент переменной/произвольной длины) обозначается через троеточие
```java
String... words 
Integer... numbers 
Person... people 
Cat... cats
```
2. Аргумент произвольной длины может быть указан только как аргумент некоторого метода:
```java
void print(String... words) 
int sum(Integer... numbers) 
void save(Person... people) 
void feed(Cat... cats)
```
3. Каждый такой аргумент переменной длины в теле метода является массивом:
```java
void print(String... words)
	{ for (int i = 0; i < words.length; i++) 
		{ System.out.println(words[i]); 
	} 
}
```
4. Vararg аргумент должен быть последним в списке аргументов метода:
```java
void print(String... words, String anotherWord) // - Так нельзя! 
void print(String... words, int someNumber) // - Так нельзя! 

void print(String anotherWord, String... words) // - Так можно 
void print(int someNumber, String... words) // - Так можно
```
5. Несмотря на то, что varargs являются массивами, при вызове метода, который принимает аргументы переменной длины, не обязательно создавать массив. Достаточно и даже желательно просто перечислить необходимые аргументы через запятую:
```java
public class Main { 
	public static void main(String... sss) { print("Как","же","прекрасно","изучать","Java"); 
   } 
	static void print(String... words){ 
		for (int i = 0; i < words.length; i++) { System.out.println(words[i]);
		 }
	}
}
```

6. Передача параметров по ссылке или по значению
>в случае с примитивами будет передача копии значения, само значение не меняется
>в случае со ссылочными типами будет копироваться адрес в памяти heap, если будем менять объект, то и старое значение изменится, так как они указывают на одну и ту же ссылку

7. Как передаются значения в метод?
>с примитивными типами копируется значение в новую переменную в скобках параметров и далее ведется работа с иной переменной, которая скопировала значение
>с ссылочными типами передача идет по значению
>
>Для примитивных типов — вы передаете копию текущего значения, для ссылок на объекты — вы передаете копию ссылки (дистанционного управления). Вы никогда не передаете объект. Все объекты хранятся в куче. Всегда.

8. Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если передать примитив?

>Массив изменится
>Передавая массив(объект) в метод, мы получаем копию ссылки, по ссылке мы можем изменить состояние объекта в хипе, но не можем поменять саму ссылку.
>При передаче примитива копируется его значение

9. JDK, JVM, JRE

>JVM (Java Virtual Machine)
> 
> JVM — это виртуальная машина Java. Она является основой для выполнения приложений на языке Java. JVM обеспечивает работу байт-кода Java, что позволяет Java быть платформо-независимым языком, так как JVM присутствует на всех основных операционных системах.
> 
>JDK (Java Development Kit)
> 
> JDK — это комплект для разработки на Java. Это основной инструмент для программиста на языке Java. JDK включает в себя JRE и набор разработчика, который включает в себя компилятор (javac), архиватор (jar) и документацию. JDK используется для разработки Java приложений и апплетов.
> 
> JRE (Java Runtime Environment)
> 
> JRE — это среда выполнения Java. Она предоставляет минимальные требования для выполнения приложения Java. JRE включает в себя JVM, библиотеки классов Java и другие модули, которые помогают JVM в выполнении программы.

10. Зачем ENUM

>ENUM  нужен для создания ограниченного списка значений

11. Методы класса енум

> `values()` - возвращает массив из всех хранящихся значений
> `ordinal()` - возвращает порядковый номер константы
> `valueOf()` - возвращает объект по имени константы в енуме

12. Может ли енум наследовать класс?

>нет, потому что он автоматически уже наследует класс ENUM 

13. Может ли имплементировать интерфейсы?
>может, например для реализации переменных в каждой константе

14. Что значит ключевое слово `native`?

> Это ключевое слово используется, когда необходимо вызвать метод, который не написан на Java, а написан на другом языке программирования, таком как C или C++.

15. Что такое нативные методы. Плюсы и минусы

> МИНУСЫ
> Нативные методы сложнее отлаживать и тестировать, так как они выполняются вне виртуальной машины Java. Они также могут создавать проблемы с портируемостью, так как разные операционные системы и платформы могут давать разные результаты для одного и того же нативного метода.
> ПЛЮСЫ
> Нативные методы в Java позволяют использовать функциональность, доступную только на уровне операционной системы или других языков программирования. Они также могут улучшить производительность при выполнении определенных задач.

16. Лямбда выражения

>**Лямбда-выражение** — это такая функция. Можете считать, что это обычный метод в Java, только его особенность в том, что его можно передавать в другие методы в качестве аргумента.
>`(параметры) -> {тело метода}`
