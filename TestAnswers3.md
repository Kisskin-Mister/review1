### Дженерики
1. Что такое дженерики?
>`Generics` - это механизм в Java, который позволяет создавать обобщенные типы данных. Он позволяет определять классы, интерфейсы и методы, которые работают с различными типами объектов, не указывая точный тип данных заранее.

2. Какую. проблему они решают?
>Они позволяют создавать более универсальные классы и методы, не прибегая к приведению типов и другим хакам.
>
>Основная проблема, которую решают generics, - это избежание ошибок связанных с типами данных (Type Safety). Без использования generics, классы могут работать только с конкретным типом данных, что может привести к ошибкам, если мы случайно используем другой тип данных. Использование generics позволяет указывать тип данных, с которыми мы работаем, непосредственно в момент создания экземпляра класса или вызова метода, что делает наш код более безопасным.
>
>Кроме того, generics также помогают повысить читаемость кода, так как они позволяют программисту указать, какие типы данных предполагаются для использования в классе или методе, что делает код более понятным и предсказуемым.

3. Что было до дженериков?
>В традиционном подходе после получения ввода проверяется тип данных ввода, а затем назначается переменная правого типа данных. При использовании этой логики длина кода и время выполнения были увеличены. Чтобы избежать этого, были введены дженерики.

4. Что можно типизировать?
>классы(интерфейсы, абстрактные классы) и методы

5. Что такое стирание и сырые типы (raw type - необработанный тип)
>`Raw type` — это класс-дженерик, из которого удалили его тип.

6. К чему приводит использование raw-type?
> raw type позволено использовать до сих пор в виду обратной совместимости джавы, так как много библиотек было написано на подобном типе

7. Какой механизм обеспечивает обратную совместимость сырых типов и дженериков?
>стирание типов

8. Если поле типизированно дженериком как в байткоде будет представлен этот тип
>Для представления типа дженерика в байт-коде Java используется так называемое «стирание типов». В результате, все ссылки на типы дженериков становятся ссылками на тип Object. Это обеспечивает обратную совместимость с библиотеками, написанными без использования дженериков, и позволяет использовать дженерики в старом коде.
>
>Однако, компилятор добавляет дополнительные байт-код инструкции для проверки типов во время выполнения. Это позволяет выполнить проверку типов на стадии выполнения и предотвратить некорректное использование дженериков. Например, при попытке присвоить переменной типа `List<String>` значение типа `List<Integer>`, будет выброшено исключение во время выполнения.

9. Как параметризировать статический метод
```java
public static <T extends Numbers> double sum(T a, T b)
```
>Мы берем обобщенный тип ==T== и наследуем его, дабы ограничить список типов, которые можно засунуть в параметризацию, и обязательно в аргументы засовываем обобщенный тип

10. Что такое даймонд оператор?
>`<>` нужен для обозначения в правой стороне при инициализации дженерик типа, иначе правая сторона будет восприниматься как сырой тип.

11. Чему эквивалентно `<?>`
> классу Object

12. Можно ли `class Animal<?>{}`
>нет

13. Принцип PECS
>производители - те, кто генерируют тип(вниз по наследству extends)
>потребители - те, кто используют значения типа (вверх по наследству super)
```java
Dog extends Pet
Cats extends Pet
Pet extends Animal
Animal extends Object

// в случае с производителем
List<? extends Animal> // --> можем засунуть Pet, Dog, Cat
// в случае с потребителем
List<? super Cat> // --> можем засунуть Pet, Animal, Object
```
14. WildCard
> `<?>` 

15. Почему последняя строчка не скомпилируется? 

```java
List<ArrayList> arrayLists = new ArrayList<ArrayList>();

ArrayList<List> arrayList = new ArrayList<ArrayList>();
```

### Коллекции
1. Что такое коллекция?
>контейнер для каких-то элементов или динамический массив

2. Какие есть типы коллекции? Как они характеризуются?
>списки(list), словари(map), наборы(set)

3. Отличие коллекции от массива
> - изменение размеров
> - в массивах примитивы и объекты, а в коллекциях классы обертки и объекты
> - у коллекций много различных методов
> - коллекции не могут быть многомерные, однако в коллекцию можно вложить коллекцию
> - коллекции поддерживают дженерики, когда как у массивов единственный неизменяемый тип данных

4. Иерархия коллекций
```
- `Collection` - базовый интерфейс, предоставляющий методы для работы с группами объектов.
- `List` - интерфейс, представляющий упорядоченную коллекцию элементов, которые могут дублироваться.
- `Set` - интерфейс, представляющий неупорядоченную коллекцию уникальных элементов.
- `Queue` - интерфейс, представляющий коллекцию элементов, расположенных по порядку.
- `Deque` - интерфейс, представляющий двустороннюю очередь, в которой элементы могут добавляться и удаляться как с конца, так и с начала.
- `Map` - интерфейс, представляющий ассоциативную коллекцию пар "ключ-значение".
- `SortedSet` - интерфейс, представляющий отсортированное множество уникальных элементов.
- `SortedMap` - интерфейс, представляющий отсортированную ассоциативную коллекцию пар "ключ-значение".
```
5. Внутреннее устройство коллекций
> коллекция состоит из интерфейса реализации и класса реализации

6. Какие структуры данных вы знаете?
>- Массив
> - Список (Динамический массив)
> - Стек
> - Очередь
> - Связный список
> - HashTable и HashMap
> - Дерево

7. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
> В зависимости от структуры данных

8. Назовите основные реализации List, Set, Queue, Map
> ArrayList, HashSet, TreeSet, LinkedList, HashMap, TreeMap

### List

1. отличие List от Set
> List - упорядоченное хранение элементов, в порядке добавления
> Set - список уникальных элементов

2. Как устроен LinkedList?
>В Java, `LinkedList` - это класс, который представляет связанный список элементов. Внутренне LinkedList реализован как двусвязный список узлов, каждый из которых содержит ссылки на следующий и предыдущий узлы в списке, а также данные, хранящиеся в этом узле.

>Когда элемент добавляется в LinkedList, он создает новый узел, содержащий данные и ссылки на предыдущий и следующий узлы. Этот узел затем добавляется в список путем обновления ссылок на соседние узлы в этих узлах.

3. Отличие ArrayList и LinkedList
>ArrayList и LinkedList являются двумя разными имплементациями интерфейса List в Java.

>Основное отличие между ArrayList и LinkedList заключается в том, как они хранят элементы.

>`ArrayList` использует массив для хранения элементов. Когда вы добавляете новый элемент в ArrayList, он добавляется в конец массива, если есть свободное место, или создается новый массив большего размера и все существующие элементы копируются в него. Это позволяет быстро получать элементы по индексу, потому что индекс соответствует индексу массива. Однако это может занимать дополнительное время при добавлении или удалении элементов из середины списка, потому что нужно перемещать все элементы за измененным элементом, чтобы освободить или занять место.

>`LinkedList` хранит элементы в виде узлов, каждый из которых содержит ссылку на следующий узел в списке. Это означает, что при добавлении или удалении элементов нет необходимости перемещать другие элементы, только нужно обновить ссылки на узлы. Однако доступ к элементам по индексу выполняется медленнее, потому что для этого нужно пройти всю цепочку узлов до нужного индекса.

4. Когда лучше юзать ArrayList, а когда LinkedList
>Итак, если вы часто получаете элементы по индексу и редко добавляете или удаляете элементы в середине списка, ArrayList может быть лучшим выбором. Если же вы часто добавляете или удаляете элементы (в том числе в середине списка), LinkedList может работать быстрее.

5. Скорость вставки элемента в начало, в середину и конец у ArrayList и LinkedList
> вставка элементов в принципе приятней через LinkedList, так как для ArrayList нужно создавать новый массив, чтобы изменить данные

6. Как работает метод `contains` в ArrayList  и LinkedList
> в ArrayList и LinkedList этот метод проверяет индекс объекта, если больше или равно 0, то возвращает тру

7. Отличие двусвязного и односвязного списка
>![[Pasted image 20231024001512.png]]

### Set
1. 3 реализации `Set`. Какая упорядоченность в какой и почему
>Класс `java.util.HashSet `в Java Collection Framework используется для хранения коллекции уникальных элементов в set (наборе, можестве). Он обеспечивает реализацию интерфейса java.util.Set на основе хэш-таблицы. Также он обеспечивает быструю вставку, удаление и поиск, но не сохраняет порядок своих элементов.
>
>LinkedHashSet тот же хэшсет, только с упорядоченным списком добавления эллементов
>
>Класс `java.util.TreeSet` в Java Collection Framework используется для хранения коллекции уникальных элементов в множестве (set), отсортированном в порядке возрастания. Он обеспечивает древовидную реализацию интерфейса java.util.Set, для хранения элементов, не допуская дублирования элементов. Класс обеспечивает быструю вставку, удаление и поиск и поддерживает порядок своих элементов в соответствии с их естественным порядком или компаратором.

2. Как работает HashSet?
> `HashSet` в `Java` - это реализация интерфейса `Set`, который использует `хэш-таблицы` для хранения элементов коллекции. `HashSet` не гарантирует порядок элементов при их переборе, и не допускает хранение дублирующихся элементов.
> 
> Основные операции, которые можно выполнить с `HashSet`:
> 
> - добавление элемента: `add()`
> - удаление элемента: `remove()`
> - проверка наличия элемента: `contains()`
> - очистка коллекции: `clear()`
> - получение размера коллекции: `size()`
> 
> `HashSet` реализован как `хэш-таблица`, где элементы хранятся в виде ключей, а значения не используются.
> 
> - При добавлении элемента, `HashSet` рассчитывает его `хэш-код` и добавляет в таблицу с соответствующим индексом.
> - Если в таблице уже есть элемент с таким же `хэш-кодом`, то выполняется проверка на равенство.
> - Если элементы равны, то новый элемент не добавляется в коллекцию, иначе он добавляется в таблицу.
> 
> При работе с `HashSet` важно правильно определить методы `hashCode()` и `equals()` для класса, который будет храниться в коллекции. Это позволит корректно выполнять поиск и удаление элементов. Если класс не переопределит методы `hashCode()` и `equals()`, то будут использоваться реализации по умолчанию, которые могут не давать ожидаемых результатов при работе с `HashSet`

3. Внутреннее устройство HashSet
> 1. `**HashSet h = new HashSet();**` — конструктор по умолчанию. Начальная емкость по умолчанию – 16, коэффициент загрузки – 0,75.
> 2. `**HashSet h = new HashSet(int initialCapacity)**` – конструктор с заданной начальной емкостью. Коэффициент загрузки – 0,75.
> 3. `**HashSet h = new HashSet(int initialCapacity, float loadFactor);**` — конструктор с заданными начальной емкостью и коэффициентом загрузки.
> 4. `**HashSet h = new HashSet(Collection C)**` – конструктор, добавляющий элементы из другой коллекции.

4. Почему в HashSet вместо value не null а new Object
> HashSet использует не null в качестве значения, а new Object, потому что хэш-таблица не может иметь пустого значения, иначе невозможно определить, содержит ли данная ячейка значение или нет. Вместо этого используется новый объект класса Object, который занимает минимальное количество памяти и не несет никакой дополнительной информации.

5. null в TreeSet
>нуль можно положить только в первый элемент списка

6. Как работает метод contains в HashSet
>HashSet основан на принципе HashMap, поэтому у каждого уникального значения есть свой ключ, поэтому метод проверяет наличие ключа в хипе

7. Различия между Set и List
>List - упорядоченное хранение элементов, в порядке добавления
> Set - список уникальных элементов

### Map
1. Что такое Мар?
> словарь значений, где у каждого элемента есть свой уникальный ключ

2. Что должно быть уникальным в Мар
> ключ

3. Почему Map не входит в Collection?
>**Map** в Java не наследуется от **Collection**, потому что она не является **коллекцией** в смысле хранения и управления группой объектов. **Map** является отображением, которое связывает каждый ключ со своим значением, поэтому обычные операции над **коллекциями**, такие как добавление, удаление и поиск, не работают для **Map** в том же самом контексте.

4. Строение HashMap? Что внутри статического класса Node
```java
static class Node<K,V> implements Map.Entry<K,V> {  
    final int hash;  
    final K key;  
    V value;  
    Node<K,V> next;  
  
    Node(int hash, K key, V value, Node<K,V> next) {  
        this.hash = hash;  
        this.key = key;  
        this.value = value;  
        this.next = next;  
    }
```
5. Как работает HashMap?
>Хэширование -это процесс преобразования объекта в целочисленную форму, выполняется с помощью метода hashCode(). Очень важно правильно реализовать метод hashCode() для обеспечения лучшей производительности класса HashMap.

6. Как расширяется HashMap?
>l;ksdjf

7. Может ли null быть ключем HashMap
>да, только один раз и он будет первый в списке

8. Какой хэш-код у null
> 0

9. Как работает метод put?
> put внутри вызывает метод putVal, который в свою очеред сначала проверяет есть ли место в хэш-таблице, потом создает объект Node с ключом и значением в параметрах дженерика, если хэш код ключей не совпадает

10. Как работает метод get  и remove в HashMap
> get метод в параметр принимет ключ, и возвращает параметризированную ноду, если нода не равна null, через метод getNode(key) 
> remove метод вызывает removeNode

11. Красно-черное дерево
> ![[Pasted image 20231024142430.png]]
> Красно-черные деревья относятся к сбалансированным бинарным деревьям поиска.  
>Как бинарное дерево, красно-черное обладает свойствами:
> 1) Оба поддерева являются бинарными деревьями поиска.  
> 2) Для каждого узла с ключом ![$ k $](https://habrastorage.org/getpro/habr/post_images/839/452/3d1/8394523d1f4bab66a8544cd365388d87.svg) выполняется критерий упорядочения:  
>   
>  ключи всех левых потомков <= ![$ k $](https://habrastorage.org/getpro/habr/post_images/839/452/3d1/8394523d1f4bab66a8544cd365388d87.svg) < ключи всех правых потомков
> 
> (в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать).  
> Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.  
>   
>  Свойства красно-черных деревьев:
> 1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).  
> 2) Корень окрашен в черный цвет.  
> 3) Листья(так называемые NULL-узлы) окрашены в черный цвет.  
> 4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.  
> 5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

12. Что гарантирует и что не гарантирует такое дерево
>самобаланс, логарифмический рост высоты дерева от числа узлов

13. Бинарное дерево поиска?

14. Коллизия. Что происходит при коллизии? Как будет решаться коллизия?
>колизия - явление которое происходит когда более одного элемента имеют одинаковый хэшкод в таблице хип
>для ее решения JVM попросту заменяет старый элемент новым

15. Как перебрать все ключи, значения, пары Мар учитывая, что Мар не Iterable?
>Использовать метод `keySet()`, который возвращает множество (`Set<K>`) ключей.
>Использовать метод `values()`, который возвращает коллекцию (`Collection<V>`) значений.
>Использовать метод `entrySet()`, который возвращает множество (`Set<Map.Entry<K, V>`) пар "ключ"-"значение".

### Queue

1. Что такое Queue?
>Queue Java – интерфейс очереди.

>Интерфейс Java Queue, java.util.Queue, представляет собой структуру данных, предназначенную для вставки элементов в конец очереди и удаления элементов из начала очереди. Это похоже на работу очереди в супермаркете.

2. В чем разница между Queue, Deque и Stack
>стек работает по принципу последним вошел - первым вышел
>queue работает по принципу первым вошел - первым вышел
>Deque расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и конец очереди) и забирать элементы с обоих краев очереди.

3. что такое Dequeue
> удаляет эллемент из начала очереди

### Iterator

1. Что такое?
>Интерфейс, а также паттерн. Дословно он переводится, как переборщик

2. когда и почему юзаем?
>для перебора и изменения или взаимодействия с элементами массива или коллекции

3. зачем там remove?
> чтобы удалять

4. Разница между Iterable & iterator
> итерабл метод который имплементируют коллекции, в нем содержится метод iterator() с параметром интерфейса Iterator

5. Как между собой связаны Iterable, Iterator & forEach?
> forEach - метод интерфейса Iterable и работает с коллекциями, итератор же может работать методом forEach с массивами

6. listIterator
>litIterator используется для перебора List
>у него побольше методов, например add(Object o)

7. Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?
>Если вызвать метод next() на объекте Iterator без предварительного вызова hasNext(), то может быть выброшено исключение NoSuchElementException.

8. Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?
>Если метод next() вызывается после 10 вызовов метода hasNext(), то будет возвращен элемент, следующий за 10-м элементом в коллекции.
