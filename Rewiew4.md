# Исключения
1. **Что такое исключение?**
    - Exception (исключительная ситуация) - это объект, который представляет ошибку или исключительную ситуацию во время выполнения программы. Исключения могут возникать при обращении к данным, работе с файлами, сетевых операциях, неправильном использовании API и других ситуациях.
2. **Иерархия исключений**
    
3. **От каких классов Throwable и его подклассов нельзя наследоваться?**
    - От ветки Error
4. **Какое назначение класса Throwable? Методы класса Throwable**
    - Класс `Throwable` - единый класс для всех исключений
    - 1. **public String getMessage()** — этот метод возвращает сообщение, которое было создано при создании исключения через конструктор.
    - 2. **public String getLocalizedMessage()** — метод, который переопределяют подклассы для локализации конкретное сообщение об исключении. В реализации `Throwable` класса этот метод просто использует метод `g``etMessage()`, чтобы вернуть сообщение об исключении (`Throwable` на вершине иерархии — ему нечего локализировать, поэтому он вызывает `getMessage())`.
    - 3. **public synchronized Throwable getCause()** — этот метод возвращает причину исключения или идентификатор в виде `null`, если причина неизвестна.
    - 4. **public String toString()** — этот метод возвращает информацию о `Throwable` в формате `String`.
    - 5. **public void printStackTrace()** — этот метод выводит информацию трассировки стека в стандартный поток ошибок, этот метод перегружен и мы можем передать `PrintStream` или `PrintWriter` в качестве аргумента, чтобы написать информацию трассировки стека в файл или поток.
5. **Чем отличаются исключения от обычных классов?**
    - Обычные классы создаются для того, чтобы создавать объекты и вызывать их методы, тогда как исключения используются для обработки ошибок и их возможного вывода в консоль.
6. **Как создать/бросить/поймать исключение.**
    - чтобы бросить исключение `throw new Exception`
    - чтобы создать исключение нужно создать класс, который будет наследовать класс Exception
    - чтобы поймать исключение:
```java
try{
//какой-то код(метод, реализация объекта или еще что)
}catch(Exception e){
//код обработки исключения
}
```
7. **Может ли main выбросить исключение?**
    - **Да**, метод main может объявить и выбросить исключение при помощи ключевого слова throws. Однако, если никакой другой код не перехватывает это исключение, то оно будет передано в систему, которая занимается управлением выполнением программы (runtime system). Когда исключение выбрасывается в методе, его можно либо перехватить и обработать (try-catch блоком), либо объявить его в сигнатуре метода (throws), чтобы передать его выше по стеку вызовов методов.
8. **Зачем создавать свой класс и наследовать его от Exception?**
    - Чтобы создать собственное исключение
9. **В чем разница между checked и unchecked исключениями.**
    - В Java исключения делятся на две категории: checked (проверяемые) и unchecked (непроверяемые).
    - `Checked исключения` - это те, которые должны быть обработаны программистом. Когда метод выбрасывает checked исключение, программа не скомпилируется, если не указано, как обработать это исключение. Это обеспечивает более надежную обработку ошибок в приложении и гарантирует, что любые потенциальные проблемы будут устранены до запуска кода.
    - `Unchecked исключения` - это те, которые не обязательно должны быть обработаны программистом. Unchecked исключения могут быть вызваны программой, но их отлавливание не обязательно. Некоторые примеры unchecked исключений включают в себя NullPointerException или ArrayIndexOutOfBoundsException.
    - Примеры проверяемых исключений в Java включают в себя IOException и InterruptedException. Например, если вы открываете файл для чтения, то вам нужно обязательно обработать возможное исключение IOException, которое может быть выброшено, если файл не существует или его нельзя прочитать по другим причинам. Аналогично, если вы работаете с многопоточностью, то вы должны обрабатывать InterruptedException, который может быть выброшен при прерывании потока.
    - Общее правило заключается в том, что если исключение может быть обработано в коде приложения, то это должно быть проверяемым исключением. Если же исключение вызвано ошибкой в программе или не может быть устранено в рамках самого приложения, то это должно быть непроверяемым исключением.
10. **Можно ли обработать непроверяемые исключения?**
    - Можно, чтобы в некоторых случаях программа не прекратила работу. Отлавливаются в trycatch.
11. **Можно ли в условии throws указать непроверяемое исключение?**
    - Можно
12. **Что такое стектрейс. Какую информацию из него можно получить?**
    - Стек-трейс, или трассировка стека — это последовательность вызовов методов, которая привела к возникновению исключения, то есть ошибки. Эта информация очень полезна при отладке кода, так как позволяет точно определить, в каком месте кода произошла ошибка.
13. **Какую информацию можно получить из StackTraceElement?**
  
14. **Можно ли после try написать несколько catch? Правило.**
    - от наследника к предку
```java
try{
someCode();
}cach(ExceptionType1 e){
handleException(e);
}cach(ExceptionType2 e){
handleException(e);
}cach(ExceptionType3 e){
handleException(e);
}
// можно так:
try {
someCode();
}catch (ExceptionType1 | ExceptionType2 | ExceptionType3 e){
handleException(e);
}
```
15. **Можно ли в одном блоке catch обработать несколько исключений?**
    - ответ сверху
16. **блок finaly.**
    - `try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. `finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.
    
    Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```
17. **4 случая когда не выполнится finally**
    **1. System.exit(-1)**
    Вызов метода System.exit() завершает выполнение приложения, независимо от того, находится ли код внутри блока try-catch-finally или нет. Если код попадает в этот метод в блоке try или catch, то блок finally не выполнится.
    
    **2. Необработанное исключение типа Error**
    
    Ошибка типа Error — это критическая ошибка во время выполнения, которую нельзя обработать обычным способом. Если такая ошибка возникает в блоке try или catch, то выполнение программы завершится, и блок finally не будет выполнен. Обычно, такие ошибки вызываются недостатком ресурсов (например, памяти).
    
    **3. Нестабильность системы**
    
    Если система нестабильна, то это может привести к сбоям в выполнении программы, что может привести к тому, что finally блок не будет выполнен.
    
    **4. Неразрешимые проблемы**
    
    Некоторые проблемы могут быть слишком сложными для решения. Например, если в программе используется неправильный тип данных, то это может привести к тому, что finally блок не будет выполнен. В таких случаях решение может быть найдено только после тщательного анализа кода и обнаружения проблемы.
18. **Будет ли выполнен finally при Error?**
    - Ошибка типа Error — это критическая ошибка во время выполнения, которую нельзя обработать обычным способом. Если такая ошибка возникает в блоке try или catch, то выполнение программы завершится, и блок finally не будет выполнен. Обычно, такие ошибки вызываются недостатком ресурсов (например, памяти).
19. **Можно ли так написать try { throw new Object(); } ? **
    - нет, нужно приведение типа сделать (Throwable)
    
20. **Конструкция try-catch-with-resource.**
    - Данная конструкция, которая появилась в Java 7, позволяет использовать блок _try-catch_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`.
    - Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.
    
    Общий вид конструкции:
```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```

21. **Что такое ресурс в конструкции try-with-resources?**
    - **Ресурсами** (**внешними ресурсами**) называют некие хранилища информации вне JVM. Это могут быть файлы, базы данных и пр.
    
    - Также вы можете встретить употребление "**ресурс**" по отношению к классу (или его объектам), предназначенному для работы с внешними ресурсами.
    
    - **Внутренние ресурсы** - это объекты, хранящиеся в памяти JVM (отсюда и разделение на внутренние и внешние ресурсы), но вряд ли вам когда-нибудь понадобится это информация.
    - Ресурсы должны имплементировать метод Closable
22. **Try с ресурсами: что если исключение вылетело сначала в try, а потом в close в конструкции try-with-recources? Какое исключение вылетит? Что будет с другим?**
    
	- Если исключение будет выброшено в основном коде и в методе `close()`, то приоритетнее будет первое исключение, а второе исключение будет подавлено, но информация о нем сохранится (с помощью метода `Throwable.addSuppressed(Throwable exception)`, который вызывается неявно Java компилятором)
23. **Когда происходит закрытие ресурсов в try-with-recources?**
    - То, как Java понимает этот код:
    - Ресурсы, открытые в скобках после оператора _try_ , понадобятся только здесь и сейчас. Я вызову их методы `.close ()` , как только закончу работу в блоке _try_ . Если в блоке _try_ возникнет исключение, я все равно закрою эти ресурсы.
24. **2 исключения, 1 в try, другое при закрытии ресурсов. Какое увидим?**
    
	- Метод `close()` может сгенерировать исключение. И если при этом основной код работы с ресурсом тоже выбросит исключение, то оно перезатрется исключением из `close()`. Информация об исходной ошибке пропадёт: мы никогда не узнаем, что было причиной исходного исключения.
25. **2 return, 1 в try, другой в finally. Какой не выполнится?**
    - не выполнится в блоке `try`
26. **2 исключения, одно в try, другое в finally. Какое увидим?** 
    - исключение в блоке `finally` может затереть исключение в блоке `try`
27. **Что такое подавленные исключения? Как достать подавленное исключение?**
    - подавленное исключение — это исключение, которое выдается, но каким-то образом игнорируется. Достается методом `Throwable.addSuppressed`
    - Если исключения выбрасываются как из блока try, так и из оператора try-with-resources, то в первом случае возникает исключение, а во втором случае исключение подавляется.
28. **Что такое ошибка, а что такое исключительная ситуация?** 
    - «Ошибка» является критическим условием, которое не может быть обработано кодом программы. «Исключение» - это исключительная ситуация, которая может быть обработана кодом программы. Существенная разница между ошибкой и исключением заключается в том, что **ошибка** вызвана нехваткой системных ресурсов, а **исключение** вызвано вашим кодом.
29. **Нужно ли ловить Error?**
    - Отлавливая “эрроры”, выполнить какие-либо действия в блоке catch, кроме [логирования](https://javarush.com/groups/posts/2388-logirovanie-chto-kak-gde-i-chem), тебе не удастся, так как это проблемы самой JVM.

# Логирование

1. **Что такое логирование и для чего используется.**
    - Логирование является важной частью разработки программного обеспечения на Java. Оно позволяет записывать информацию о работе приложения, ошибки и предупреждения для последующего анализа и отладки программы. Логирование позволяет лучше понять, как ваше приложение работает и помогает найти и исправить возникающие проблемы.
2. **Какие есть уровни логирования и для чего они нужны?**
    1. SEVERE (ошибка)
    2. WARNING (предупреждение)
    3. INFO (информационное сообщение)
    4. CONFIG (в общем случае записывается информация журнала, такая как загрузка файлов конфигурации.)
    5. FINE (сообщение об успешной операции)
    6. FINER
    7. FINEST
    8. OFF: can be used to turn OFF log information without outputting logs of any level.  
    9. ALL: log information at ALL levels
    
3. **Чем отличаются FINE FINER FINEST?**
    - отличаются детализацией логирования
4. **Сообщения каких уровней мы увидим, задав уровень INFO?**
    - WARNING & SERVE
5. **Обязательно ли передавать в метод getLogger() имя класса? Почему так принято?**
    - Потому что на разных уровнях программы могут быть свои логи, а могут не быть, поэтому чтобы не записывать информацию от всей программы, используется прописание класс логгирования
