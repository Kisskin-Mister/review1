1. Чем процесс отличается от потока?
    - **Процесс** - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.
    - **Поток** - это последовательность инструкций, выполняющаяся внутри процесса. Потоки делят адресное пространство памяти процесса, что позволяет им работать параллельно.
    - ==Основное отличие процесса от потока в том, что "содержимое" потока просто "движется" (оставаясь тем же самым), а процесс это взаимодействие его "содержимого" с изменением соотношения его "частей" и свойств (внешне процесс может выглядеть и "неподвижным").==
2. Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? (Ответ что тред - это класс,  а ранбл интерфейс - считается не полным, нужно рассказать подробно)
    - Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями. Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable. Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread
3. Что такое монитор? Как монитор реализован в java?
    - Когда речь заходит о "мониторе" в Java, можно представить его как некий "замок" или "ограждение", которое обеспечивает безопасный и синхронизированный доступ к общим ресурсам между несколькими потоками.
    - В Java монитор реализован с помощью ключевого слова synchronized.
4. Что такое синхронизация? Какие способы синхронизации существуют в java?
    - Синхронизация это процесс, который позволяет выполнять потоки параллельно.  
    - В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта.
    - Способы синхронизации в Java:
        - Системная синхронизация с использованием wait()/notify().
            - Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!
        - Системная синхронизация с использованием join().  
            - Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.  
        - Использование классов из пакета java.util.concurrent.Locks - механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.
5. Как работают методы wait(), notify() и notifyAll()?
    - wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();  
    - notify(): продолжает работу потока, у которого ранее был вызван метод wait();  
    - notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().
    - Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.
    - wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.
6. В каких состояниях может находиться поток?
    - NEW - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется. Runnable - поток готов к выполнению, но планировщик еще не выбрал его.  
    - RUNNING – поток выполняется.  
    - WAITING/blocked/sleeping - поток блокирован или поток ждет окончания работы другого потока.
    - DEAD - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока.  
7. Что такое семафор? Как он реализован в Java?
    - Semaphore действует как контроллер, контролирующий доступ к ограниченному ресурсу. Он предоставляет доступным только определенное количество потоков одновременно, в то время как остальные ждут, пока не освободится место. Это помогает предотвратить перегрузку и создать более организованный и безопасный процесс.
8. Что означает ключевое слово volatile? Почему операции над volatile переменными не атомарны?
    - Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.  
    - Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине.
    - Атомарная операция выглядит единой и неделимой командой процессора.
    - volatile переменная обеспечивает видимость изменений, внесенных одним потоком, всем другим потокам, обеспечивая правильную синхронизацию и избегая устаревших или несогласованных значений
    - Атомарная операция — это операция в одно действие.
9. Для чего нужны Atomic типы данных? Чем отличаются от volatile?
    - volatile не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому что count объявлена volatile.  
    - C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.
    - volatile обеспечивает только видимость изменений, а классы Atomic* дают еще и атомарность изменений.  
    - Простой пример - вам нужно проинкрементить счетчик и вернуть значение. Если поле счетчика будет обычным volatile int - возможна ситуация, когда два разных потока сначала проведут инкремент, а потом оба заберут результат двух инкрементов.
    - Если же взять AtomicInteger, будет гарантирована атомарность, и каждый поток получит правильный результат.
    - Типичное применение volatile:  
        - флаги (например, флаг выполнения потока);  
        - поля в POJO, которые используются только для хранения данных, когда по какой-то причине нет возможности использовать final- поля.
10. Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?
    - Когда все обычные потоки завершат свою работу, поток демон может быть остановлен автоматически, даже если он еще не закончил свою задачу. Таким образом, поток демон остается активным до тех пор, пока программа работает, но не задерживает окончание работы программы.
    - Создание демон-потока в Java не сложнее, чем создание обычного потока. Все, что нужно сделать — это вызвать метод `setDaemon(true)` для объекта потока перед его запуском.
11. Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?
    - Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).
    - Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5. Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.  
    - Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.
12. Как работает Thread.join()? Для чего он нужен?
    - Когда поток вызывает join(), он будет ждать пока поток, к которому он присоединяется, будет завершён, либо отработает переданное время:  
    - void join()  
    - void join(long millis) - с временем ожидания
    - void join(long millis, int nanos)  
    - Применение: при распараллелили вычисления, вам надо дождаться результатов, чтобы собрать их в кучу и продолжить выполнение.
13. Чем отличаются методы wait() и sleep()?
    - метод sleep() - приостанавливает поток на указанное время. Состояние меняется на WAITING, по истечению - RUNNABLE.  
    - метод wait() - меняет состояние потока на WAITING. Может быть вызван только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException
    - Таким образом, разница между методами wait() и sleep() заключается в их целях. Метод wait() используется для ожидания выполнения определенных условий, прежде чем продолжить работу, а метод sleep() используется для создания временной паузы в работе потока.
14. Можно ли вызвать start() для одного потока дважды?
    - Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение. Выдает: IllegalThreadStateException
15. Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted()
    - Остановка потока:
        - Когда мы хотим остановить поток, мы должны использовать механизмы, которые позволяют потоку корректно завершить работу и освободить ресурсы. В Java рекомендуется использовать согласованный подход для остановки потока, который включает проверку флага состояния и признака прерывания.
        - Метод `.stop()` устарел и не рекомендуется к использованию. Этот метод немедленно останавливает поток, даже если он находится в середине выполнения. Однако это может привести к непредсказуемым результатам и нарушению состояния потока и программы. Поэтому лучше не использовать этот метод.
        - Метод `.interrupt()` позволяет отправить сигнал прерывания потоку. Он устанавливает флаг состояния прерывания для потока. Это означает, что код потока должен периодически проверять этот флаг и реагировать соответствующим образом. Метод .interrupt() не останавливает поток немедленно, а лишь активирует флаг прерывания.
        - Методы `.interrupted()` и `.isInterrupted()` позволяют проверить текущее состояние флага прерывания потока. Разница между ними в том, что метод `.interrupted()` статический и сбрасывает флаг прерывания, а метод `.isInterrupted()` не сбрасывает флаг.
    - Таким образом, чтобы остановить поток, мы должны использовать метод `.interrupt()` для установки флага прерывания и периодически проверять его значение с помощью метода `.isInterrupted()` или `.interrupted()`, чтобы корректно завершить работу потока.
16. Чем Runnable отличается от Callable?
    - 1. Возвращаемое значение:
        - Интерфейс Runnable не имеет возвращаемого значения. Метод run() возвращает void и не может вернуть какое-либо значение.
        - Интерфейс Callable имеет возвращаемое значение заданного типа. Метод call() возвращает значение, которое может быть получено в результате выполнения задачи.
    2. Исключения:
        - Метод run() интерфейса Runnable не может выбрасывать проверяемые исключения. Он может выбросить только непроверяемые исключения.
        - Метод call() интерфейса Callable может выбрасывать проверяемые исключения.
17. Что такое FutureTask?
    - FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.
    - FutureTask позволяет тебе максимально эффективно использовать время и не ждать, пока одна задача закончится, чтобы начать следующую. Он также предоставляет возможность получить результат, когда задача выполнена.
18. Что такое deadlock?
    - Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания и своё состояние не меняют. Происходит, когда достигаются состояния:
        - взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени.  
        - удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.
        - отсутствия предочистки: операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.  
        - цикличного ожидания: поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.
    - Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.
19. Что такое livelock?
    - livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock. Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.
20. Что такое race condition?
    - Race condition (состязательная ситуация) - это ситуация, когда несколько потоков одновременно обращаются к общим ресурсам, и результат выполнения программы зависит от того, какой поток будет выполняться быстрее. Когда такие потоки мешают друг другу или взаимодействуют неправильно, возникают проблемы. Результат выполнения может быть случайным и зависеть от порядка выполнения потоков.
    - Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками.
21. Что такое Фреймворк fork/join? Для чего он нужен?
    1. Разделение (fork): Исходная задача разбивается на несколько более мелких подзадач, которые могут быть выполнены параллельно. Каждая подзадача представляет собой некоторую часть работы, которую необходимо выполнить.
    2. Выполнение (compute): Подзадачи выполняются параллельно на различных потоках. Каждый поток работает над своей подзадачей, которая была выделена Центральным процессором (CPU).
    3. Слияние (join): Когда все подзадачи завершены, их результаты собираются в общий результат. Результаты каждой подзадачи сливаются вместе, чтобы получить итоговый результат работы.
22. Что означает ключевое слово synchronized? Где и для чего может использоваться?
    - Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.
23. Что является монитором у статического synchronized-метода?
    - Объект типа Class, соответствующий классу, в котором определен метод.
24. Что является монитором у нестатического synchronized-метода?
    - Объект `this`
25. `util.concurrent` поверхностно.
    1. Интерфейсы `Executor и ExecutorService`: они позволяют управлять выполнением задач в пуле потоков. `Executor` предоставляет метод `execute()` для выполнения задачи, а `ExecutorService` расширяет его функциональность, позволяя отправлять задачи на выполнение и получать результаты.
    2. Классы `ThreadPoolExecutor` и `Executors`: они предоставляют реализации интерфейса `ExecutorService` для создания и управления пулами потоков. `ThreadPoolExecutor` обеспечивает гибкую настройку параметров пула потоков, а класс `Executors` предоставляет методы для создания предопределенных типов пулов потоков.
    3. Классы Future и `FutureTask`: они позволяют выполнять асинхронные операции и получать результаты выполнения. Интерфейс Future представляет собой результат выполнения асинхронной операции, а класс `FutureTask` является конкретной реализацией интерфейса Future и предоставляет дополнительные возможности для управления выполнением задачи.
    4. Классы `CountDownLatch` и `CyclicBarrier`: они предоставляют механизмы синхронизации потоков. `CountDownLatch` используется для ожидания выполнения некоторого количества операций, а `CyclicBarrier` обеспечивает точку синхронизации, в которой потоки должны остановиться и дождаться друг друга.
    - В пакете `java.util.concurrent` также есть другие полезные классы, такие как `Semaphore`, `Lock`, `Condition` и др., которые предоставляют дополнительные возможности для управления потоками и синхронизации операций.
    - В целом, пакет `java.util.concurrent` предлагает удобные инструменты для разработки многопоточных и асинхронных приложений, обеспечивая эффективную работу с потоками и синхронизацию операций.
26. Stream API & ForkJoinPool. Как связаны, что такое
    - Stream API представляет собой функциональный интерфейс в пакете java.util.stream, который позволяет легко и эффективно обрабатывать коллекции данных. Он позволяет выполнять различные операции над элементами коллекции, такие как фильтрация, отображение, сортировка и т. д., используя функциональные выражения (лямбда-выражения) для описания операций.
    - ForkJoinPool является реализацией интерфейса ExecutorService, который используется для планирования и выполнения параллельных задач. Он использует разделение и слияние (fork-join) для распределения работы между потоками и объединения результатов
    - Оба Stream API и ForkJoinPool предоставляют возможности для эффективной обработки данных и выполнения операций параллельно. Stream API упрощает кодирование последовательных операций, а ForkJoinPool позволяет эффективно использовать вычислительную мощность многопроцессорной системы. Использование их вместе позволяет повысить производительность и ускорить выполнение задач обработки данных.
27. Java Memory Model
    - Java Memory Model Описывает как потоки должны взаимодействовать через общую память. Определяет набор действий межпоточного взаимодействия. В частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока.  <br>JMM определяет отношение между этими действиями "happens-before" - абстракцей обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X