## Сериализация
#### Что такое «сериализация»?
Сериализация – это процесс сохранения состояния объекта в последовательность байт; Реализована через интерфейс - маркер Serializable.
Нужна для компактного сохранения состояния объекта и считывание этого состояния.
#### Опишите процесс сериализации/десериализации с использованием Serializable.
1) Класс объекта должен реализовывать интерфейс Serializable  
2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream. 3) Записать в поток: oos.writeObject(Object);  
4) Сделать oos.flush() и oos.close()
#### Как изменить стандартное поведение сериализации/десериализации?
Использовать интерфейс Externalizable.

Переопределить методы  
writeExternal(ObjectOutput out) throws IOException readExternal(ObjectInput in) throws IOException, ClassNotFoundException
#### Как исключить поля из сериализации?
1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.
2) Сделать поле static. Значения статических полей автоматически не сохраняются.
#### Что обозначает ключевое слово transient?
что поле не будет участвовать в сериализации
#### Какое влияние оказывают на сериализуемость модификаторы полей static и final
1. Значения статических полей автоматически не сохраняются.
2. Поля с модификатором `final` сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.
#### Как не допустить сериализацию?
?

#### Как создать собственный протокол сериализации?
Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().  
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.
#### Какая роль поля serialVersionUID в сериализации?
Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.  
Если мы не объявляем его явно, Java делает это за нас.
#### Когда стоит изменять значение поля serialVersionUID?
Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.
#### В чем проблема сериализации Singleton?
- Проблема -  
в том что после десериализации мы получим другой объект.
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.

- Решение -  
В классе определяется метод с сигнатурой  
"Object readResolve() throws ObjectStreamException"

- Назначение -  
этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.
#### Какие существуют способы контроля за значениями десериализованного объекта
?

## IO/NIO

#### Что такое InputStream и OutputStream.
это абстрактные классы в Java, предназначенные для операций чтения и записи данных соответственно. InputStream используется для чтения данных из источника, например файла или сетевого соединения, а OutputStream используется для записи данных в цель, такую как файл или сетевое соединение.

#### Каких видов потоковый ввод бывает.
- Байтовый поток ввода (InputStream) для чтения данных в виде байтов.
- Символьный поток ввода (Reader) для чтения данных в текстовом формате.
- Объектный поток ввода (ObjectInputStream) для чтения сериализованных объектов.

#### Что такое System.in и System.out.
System.in и System.out являются стандартными потоками ввода и вывода в Java. System.in представляет стандартный поток ввода, через который можно считывать данные с клавиатуры или другого источника ввода. System.out представляет стандартный поток вывода, через который можно выводить данные на консоль или другую цель вывода.

#### На каком паттерне основана иерархия потоков ввода/вывода.
Иерархия потоков ввода/вывода в Java основана на паттерне "Декоратор" (Decorator pattern). Этот паттерн позволяет добавлять новые функциональные возможности к объектам без изменения их основной структуры. В случае потоков ввода/вывода, паттерн "Декоратор" позволяет обернуть базовые потоки ввода/вывода дополнительными функциями, такими как буферизация или шифрование.

#### Классы байтовых потоков ввода и что они делают?
Классы байтовых потоков ввода, такие как FileInputStream и ByteArrayInputStream, предназначены для чтения данных в виде байтов. Они обеспечивают методы для чтения байтов из файла, массива или другого источника ввода. Байтовые потоки ввода часто используются для чтения двоичных данных, таких как изображения или аудиофайлы.

#### Классы байтовых потоков вывода и что они делают? 
Классы байтовых потоков вывода, такие как FileOutputStream и ByteArrayOutputStream, предназначены для записи данных в виде байтов. Они обеспечивают методы для записи байтов в файл, массив или другой цель вывода. Байтовые потоки вывода часто используются для записи двоичных данных, таких как файлы или сетевые потоки.  

#### Классы символьных потоков ввода и что они делают?
Классы символьных потоков ввода, такие как FileReader и StringReader, предназначены для чтения символьных данных, как правило, в текстовом формате. Они обеспечивают методы для чтения отдельных символов или строк из источника ввода. Символьные потоки ввода предоставляют более удобные методы чтения текста и поддерживают разные кодировки.
#### Классы символьных потоков вывода и что они делают?
Классы символьных потоков вывода, такие как FileWriter и StringWriter, предназначены для записи символьных данных в текстовом формате. Они обеспечивают методы для записи отдельных символов или строк в цель вывода. Символьные потоки вывода обеспечивают возможность записи текста и поддерживают разные кодировки для сохранения символов в соответствующих форматах.
#### Отличие пакетов IO и NIO, InputStream от Reader.
IO и NIO - это два разных подхода к работе с вводом-выводом данных. IO использует потоки (streams) для чтения и записи данных, в то время как NIO использует буферы (buffers) и каналы (channels). InputStream и Reader - это классы для чтения данных, но с разными кодировками. InputStream работает с байтами, а Reader работает с символами.  

#### Что вы знаете о RandomAccessFile?
RandomAccessFile - это класс в Java, который позволяет работать с файлами в режиме случайного доступа. Он позволяет перемещаться по файлу и читать/записывать данные с любой позиции.

#### Какие есть режимы доступа к файлу?
Режимы доступа к файлу включают:
   - Чтение (Read) - разрешено только чтение данных из файла.
   - Запись (Write) - разрешено только запись данных в файл.
   - Обновление (ReadWrite) - разрешено как чтение, так и запись данных в файл.
   - Создание (Create) - создание нового файла, если он не существует.
   - Удаление (Delete) - удаление файла после чтения или записи.

#### как работает метод read?
Метод read используется для чтения данных из InputStream или Reader. Он считывает следующий байт или символ из потока и перемещает указатель чтения на следующую позицию.
#### Почему read возвращает int а не byte.
Потому что **byte** может удерживать только -128 до 127, тогда как он должен **возвращать** 0 до 255 
Если метод возвращает -1, это означает, что достигнут конец файла или потока и больше данных не осталось для чтения.  

#### Что вернет метод read(), если он считывает файл и ему встречается байт равный -1? И почему он вернет именно это значение?
В Java нет беззнаковых типов. `read()` возвращает байт без знака, и единственный способ представить его в Java - использовать `int` type .

`byte` значения находятся в `-128..127` диапазоне, в то время как байт без знака имеет значения в `0..255` диапазоне.

Метод read() возвратит -1, если он считывает файл и встречает байт со значением -1 (0xFF). Это значение используется для обозначения конца потока или файла в Java. Таким образом, возвращая -1, метод read() сообщает о достижении конца файла или потока.
  
#### Что делает метод flush() 
Метод flush() используется для принудительной записи данных из буфера на устройство вывода. Он гарантирует, что все данные, находящиеся в буфере, будут записаны, даже если буфер не полностью заполнен.

#### Как преобразовать считанные байты сразу в  символы
Для преобразования считанных байт в символы можно использовать класс InputStreamReader. Он принимает InputStream или Reader в конструкторе и предоставляет методы для чтения символов, автоматически конвертируя байты в символы с использованием указанной кодировки.

#### В чем отличие Scanner от BufferedReader
Одно из основных отличий между Scanner и BufferedReader заключается в их функциональности. Scanner предоставляет удобные методы для считывания примитивных типов данных и строк из входного потока данных, также позволяет разбирать данные на токены с использованием разделителя. BufferedReader более эффективен при работе с большими объемами данных, так как он использует буферизацию для уменьшения количества операций ввода-вывода.
  

#### Что вы знаете о классах-надстройках?
![[Pasted image 20231101132048.png]]
  

#### Когда создаешь экземпляр класса File создается ли что-то на жестком диске
При создании экземпляра класса File ничего не создается на жестком диске. Класс File представляет путь к файлу или директории, и его создание не приводит к созданию самого файла или директории на диске. Он просто предоставляет методы для работы с путями и манипулирования файлами и директориями

#### Разница между mkdir и mkdirs
Метод mkdir используется для создания только одной новой директории, тогда как метод mkdirs используется для создания новой директории или нескольких директорий вместе с их родительскими директориями. Если родительские директории не существуют, то mkdirs автоматически создаст их. 

#### Класс File
Класс File в Java представляет файл или директорию в файловой системе. Он предоставляет методы для работы с файлами и директориями, такие как создание, удаление, переименование, проверка существования и многое другое.  

#### интерфейс FilenameFilter
Интерфейс FilenameFilter используется для фильтрации файлов по имени в определенной директории. Он определяет метод accept, который принимает директорию и имя файла в качестве параметров и возвращает true, если файл соответствует критериям фильтра, или false в противном случае.  

#### Отличия File от Path
Path - интерфейс, он в отличие от File может выкидывать исключения, читать метаданные, для создания объекта не нужен конструктор
  

#### Что возвращают медоты File, Path.
Path - всегда Path, File много чего может возвращать
  

#### Разница между абсолютным и относительным путем
Абсолютный путь представляет полный путь к файлу или директории, начиная от корневой директории файловой системы. Относительный путь представляет путь к файлу или директории относительно текущей директории или другой относительной точки.

#### Что такое «каналы»?
Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.
  

#### Как создать файл на компьютере с помощью java.

 Чтобы создать файл на компьютере с помощью Java, нужно использовать класс File и его методы для создания экземпляра файла и записи в него данных. Пример кода: 

```java
File file = new File("путь_к_файлу");
if (file.createNewFile()) {
    System.out.println("Файл создан");
} else {
    System.out.println("Файл уже существует");
}
```

  

#### Как удалить директорию с файлами.
Для удаления директории с файлами в Java можно использовать класс File и его методы для удаления директории и всех ее содержимого. Пример кода:

```java
File directory = new File("путь_к_директории");
if (directory.exists() && directory.isDirectory()) {
    File[] files = directory.listFiles();
    if (files != null) {
        for (File file : files) {
            file.delete();// <-- вот этот метод удаляет файл
        }
    }
    directory.delete(); // <-- а этот директорию
    System.out.println("Директория удалена");
} else {
    System.out.println("Директория не существует");
}
```