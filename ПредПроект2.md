1. Что такое бин? 
    1. Бин - это объект, который управляется Spring IoC контейнером. Бины создаются с помощью конфигурационной метаданных, которые вы предоставляете контейнеру.
2. Виды бинов? 
    2. Виды бинов: Singleton (один экземпляр на Spring IoC контейнер), Prototype (новый экземпляр каждый раз), Request (один экземпляр на HTTP-запрос), Session (один экземпляр на HTTP-сессию), Global-session (один экземпляр на глобальную HTTP-сессию).
3. Чем бин отличается от POJO-класса? 
    3. Бин - это объект, управляемый Spring IoC контейнером, в то время как POJO (Plain Old Java Object) - это простой объект Java, который не связан с любыми специфическими Java-фреймворками.
4. Что такое Inversion of Control и как Spring реализует этот принцип? 
    4. Inversion of Control (IoC) - это принцип, при котором контроль над вызовами методов переходит от пользовательского кода к контейнеру. Spring реализует этот принцип через Dependency Injection (DI) и Service Locator pattern.
5. Для чего существует такое количество ApplicationContext? 
    1. **AnnotationConfigApplicationContext**: Если вы используете полностью аннотированную конфигурацию, вы можете использовать этот контекст, который позволяет вам зарегистрировать классы конфигурации аннотированные @Configuration.
    2. **ClassPathXmlApplicationContext**: Этот контекст загружает файлы конфигурации из classpath. Это наиболее часто используемый контекст.
    3. **FileSystemXmlApplicationContext**: Этот контекст загружает файлы конфигурации из файловой системы.
    4. **WebApplicationContext**: Этот контекст предназначен для использования в веб-приложениях.
    5. **StaticApplicationContext**: Этот контекст позволяет программно зарегистрировать бины и сообщения, а затем закрыть контекст. Он полезен для тестирования.
    6. **DynamicApplicationContext**: Этот контекст также позволяет программно зарегистрировать бины, но он может быть обновлен в любое время, с новыми определениями бинов, которые могут переопределить существующие и добавить новые.
6. Как можно связать бины? 
    6. Бины можно связать с помощью Dependency Injection, который может быть осуществлен через конструктор, сеттеры или аннотации.
7. Что такое Dependency Injection? 
    7. Dependency Injection (DI) - это процесс, при котором объект получает свои зависимости от внешних источников вместо самостоятельного создания их.
8. Какие бины будут использоваться для настройки приложения?
    Бины, которые будут использоваться для настройки приложения, в значительной степени зависят от конкретного приложения и его требований. Однако, в общем случае, в Spring-приложении могут быть следующие типы бинов:
    1. **DataSource Bean**: Этот бин обычно используется для настройки подключения к базе данных.
    2. **SessionFactory Bean или EntityManagerFactory Bean**: Эти бины используются для настройки фабрики сессий Hibernate или JPA.
    3. **TransactionManager Bean**: Этот бин используется для управления транзакциями в Spring-приложении.
    4. **Beans для сервисов**: Эти бины представляют сервисы в вашем приложении, которые содержат бизнес-логику.
    5. **Beans для DAO или Repository**: Эти бины представляют классы доступа к данным, которые взаимодействуют с базой данных.
    6. **Beans для контроллеров**: Эти бины представляют контроллеры в MVC-приложении Spring, которые обрабатывают пользовательский ввод.
    7. **Beans для ViewResolver**: Этот бин используется для определения, как представления разрешаются в MVC-приложении Spring.
    8. **Beans для других инфраструктурных компонентов**: В зависимости от вашего приложения, могут быть другие бины для таких вещей, как настройка безопасности, настройка кэширования, настройка планирования задач и т.д.
    Все эти бины обычно определяются в конфигурационном файле Spring или в классе конфигурации, аннотированном `@Configuration`
9. Как получить данные из файла .property? 
    9. Данные из файла .property можно получить с помощью класса Properties или с помощью аннотации @PropertySource в Spring.
10. Как запустить Спринг-приложение из-под сервера Tomcat? 
    10. Для запуска Spring-приложения из-под сервера Tomcat, вам нужно создать WAR-файл вашего приложения и развернуть его на сервере Tomcat.
11. Что такое Artifacts? 
    11. Artifacts - это результаты сборки проекта, которые могут быть развернуты на сервере. Например, JAR, WAR или EAR файлы.
12. В чем отличие артефакта war от war exploded? 
    12. WAR-файл - это архив, который можно развернуть на сервере, в то время как WAR exploded - это распакованная версия WAR-файла, которую можно использовать для разработки и отладки.
13. Какая разница между аннотациями @Component, @Repository и @Service в Spring? 
    13. @Component, @Repository и @Service - это аннотации Spring, которые используются для определения бинов. @Component - это общая аннотация, @Repository используется для DAO, а @Service - для сервисов.
14. Как выглядит структура MVC-приложения? 
    14. Структура MVC-приложения включает в себя модель (Model), представление (View) и контроллер (Controller).
15. Чем контроллер отличается от сервлета? 
    15. Контроллер - это часть MVC, которая обрабатывает пользовательский ввод и обновляет модель. Сервлет - это класс Java, который обрабатывает HTTP-запросы в веб-приложении.
16. Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно? 
    16. Основная зависимость фреймворка Spring - это spring-context. Она часто не указывается явно, потому что другие зависимости Spring включают ее автоматически.
17. Как вернуть страницу в контроллере? Как вернуть данные?
    17. В контроллере можно вернуть страницу, возвращая имя представления, или данные, возвращая объект @ResponseBody.
18. Уметь рассказать про принципы работы Spring. 
    1. Inversion of Control (IoC): Spring применяет принцип IoC, который означает, что контроль за созданием и управлением объектами переходит от приложения к фреймворку. Вместо того чтобы явно создавать объекты, вы описываете их зависимости и связи в конфигурационных файлах или с помощью аннотаций, и Spring берет на себя ответственность за создание и управление этими объектами.
    2. Dependency Injection (DI): Spring реализует механизм DI, который позволяет внедрять зависимости в объекты автоматически. Вместо того чтобы объекты создавали и управляли своими зависимостями, они объявляют свои зависимости и позволяют Spring внедрять их при создании объектов или во время выполнения.
    3. Aspect-Oriented Programming (AOP): Spring поддерживает AOP, который позволяет вынести поперечную функциональность (cross-cutting concerns) из основного кода приложения. С помощью AOP вы можете модульно и масштабируемо реализовывать аспекты, такие как транзакции, журналирование, безопасность и кэширование, и применять их к различным компонентам приложения без изменения самого кода.
    4. Контейнер приложений: Spring предоставляет контейнер приложений, который управляет жизненным циклом объектов и предоставляет различные сервисы, такие как инъекция зависимостей, управление транзакциями, обработка исключений и другие. Контейнер поддерживает конфигурацию через XML, аннотации или Java-код, что делает его гибким и расширяемым.
    5. Модульность и расширяемость: Spring позволяет создавать приложения из модулей, которые могут быть подключены и отключены при необходимости. Фреймворк предоставляет множество функциональных модулей, таких как Spring MVC, Spring Data, Spring Security и другие, которые могут быть легко интегрированы в приложение с помощью зависимостей Maven или Gradle.
    6. Тестирование: Spring обеспечивает хорошую поддержку для написания тестов. Он предоставляет механизмы для создания тестовых контекстов, внедрения зависимостей и управления жизненным циклом объектов, что делает тестирование более простым и эффективным.
19. Связывание бинов и их жизненный цикл. 
    Связывание бинов в Spring обычно происходит через Dependency Injection (DI). DI - это процесс, при котором Spring контейнер внедряет зависимости в бины при их создании. Это может быть сделано через конструкторы, сеттеры или поля, аннотированные `@Autowired`.
    **Жизненный цикл бинов:**
    Жизненный цикл бина в Spring включает следующие этапы:
    1. **Инстанцирование**: Spring контейнер создает экземпляр бина.
    2. **Заполнение свойств**: Spring контейнер внедряет зависимости в бин.
    3. **Установка Bean Name**: Если бин реализует интерфейс `BeanNameAware`, Spring устанавливает имя бина.
    4. **Установка Bean Factory**: Если бин реализует интерфейс `BeanFactoryAware`, Spring устанавливает фабрику бина.
    5. **Pre-initialization**: Если бин реализует интерфейс `BeanPostProcessor`, Spring вызывает метод `postProcessBeforeInitialization`.
    6. **Инициализация**: Если бин реализует интерфейс `InitializingBean`, Spring вызывает метод `afterPropertiesSet`. Кроме того, если для бина определен метод инициализации, Spring вызывает этот метод.
    7. **Post-initialization**: Если бин реализует интерфейс `BeanPostProcessor`, Spring вызывает метод `postProcessAfterInitialization`.
    8. **Уничтожение**: Если бин реализует интерфейс `DisposableBean`, Spring вызывает метод `destroy`. Кроме того, если для бина определен метод уничтожения, Spring вызывает этот метод.
    Важно отметить, что жизненный цикл бина может быть управляем с помощью различных callback-методов и аннотаций, таких как `@PostConstruct` и `@PreDestroy`.
20. Основные паттерны Spring.
    Spring Framework использует множество шаблонов проектирования для обеспечения гибкости и удобства использования. Вот некоторые из основных шаблонов, используемых в Spring:
    1. **Singleton**: Этот шаблон гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к нему. В Spring, бины по умолчанию являются синглтонами.
    2. **Prototype**: Этот шаблон используется, когда каждый запрос бина должен возвращать новый экземпляр. Это противоположность синглтону.
    3. **Factory Method**: Этот шаблон используется для создания объектов без указания точного класса объекта, который будет создан. В Spring, `BeanFactory` использует этот шаблон.
    4. **Abstract Factory**: Этот шаблон предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов. `BeanFactory` является примером этого шаблона.
    5. **Builder**: Этот шаблон используется для построения сложных объектов шаг за шагом. Он также предоставляет возможность использовать один и тот же процесс построения для создания различных представлений объектов.
    6. **Template Method**: Этот шаблон определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма без изменения его структуры. Примеры в Spring включают `JdbcTemplate`, `HibernateTemplate` и `RestTemplate`.
    7. **Decorator**: Этот шаблон позволяет добавлять новые функции к объектам, динамически оборачивая их в объекты декораторов. Это используется в Spring AOP.
    8. **Proxy**: Этот шаблон предоставляет объект, который контролирует доступ к другому объекту. Spring AOP и транзакционное управление используют этот шаблон.
    9. **Front Controller**: Этот шаблон предоставляет централизованный контроллер, который управляет запросами и обновлениями в представлении. В Spring MVC, `DispatcherServlet` является примером этого шаблона.
    10. **MVC**: Этот шаблон разделяет приложение на три основные компонента: модель, представление и контроллер. Spring MVC является реализацией этого шаблона.
    11. **Dependency Injection (DI)**: Этот шаблон используется для уменьшения связанности кода путем управления зависимостями между объектами. Это основной шаблон, используемый в Spring для управления бинами.
    12. **Inversion of Control (IoC)**: Этот шаблон относится к передаче управления внешнему сервису, который управляет потоком приложения. Spring IoC контейнер является примером этого шаблона.
