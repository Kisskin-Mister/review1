#### Что такое функциональное программирование и где оно применяется? 
Функциональное программирование - это стиль программирования, где основной упор делается на использование функций, которые могут быть переданы как аргументы, возвращены из других функций и сохранены в переменных. Оно применяется во многих областях, но особенно полезно, когда требуется обработка больших объемов данных или параллельное выполнение операций.

#### Императивный vs Декларативный подход
`Императивный` подход в программировании описывает последовательность действий для выполнения задачи, тогда как `декларативный` подход описывает желаемый результат, не указывая, как его достичь.

#### Что такое функциональный интерфейс (java.util.function) и для чего он нужен и зачем были добавлены?
Функциональный интерфейс - это интерфейс, который содержит только один абстрактный метод и может использоваться в качестве целевого типа для лямбда-выражений или методов ссылки. Они были добавлены в Java для поддержки функционального программирования и упрощения написания кода, основанного на функциях.

#### Основные семейства функциональных интерфейсов?(5 семейств)
Основные семейства функциональных интерфейсов в Java:
1) `Consumer` - принимает входной аргумент и ничего не возвращает;
2) `Supplier` - не принимает входных аргументов и возвращает результат;
3) `Function` - принимает входной аргумент и возвращает результат;
4) `Predicate` - принимает входной аргумент и возвращает логическое значение;
5) `Operator` - принимает входные аргументы и возвращает результат того же типа.

#### Что такое инстанцирование?
Инстанцирование - это процесс создания объекта класса, который описывает, как объект будет выглядеть и какие действия он может выполнить.

#### Какие есть способы инстанцировать функциональные интерфейсы?
Способы инстанцировать функциональные интерфейсы в Java:
1) Создание анонимного класса, реализующего функциональный интерфейс;
2) Использование лямбда-выражений;
3) Использование ссылок на методы.

#### Все способы реализовать функциональные интерфейсы?
Все способы реализовать функциональные интерфейсы в Java были перечислены выше: создание анонимного класса, использование лямбда-выражений и ссылок на методы.

#### Сколько дефолтных методов и статических методов, статических полей в интерфейсе?
В интерфейсе можно объявить неограниченное количество дефолтных методов и статических методов, а также статические поля.

#### Что такое default методы? В какой Java введены и для чего? (8)
Default методы - это методы, которые могут иметь реализацию по умолчанию в самом интерфейсе. Они были введены в Java 8 для того, чтобы добавить новые функциональности в интерфейсы без необходимости изменения всех классов, которые их реализуют. Это позволяет сделать интерфейсы более гибкими и расширяемыми.

#### Что такое method Reference?(::) Является ли лямбдой?(частный случай лямбды)
Method Reference (::) - это способ ссылаться на уже существующий метод или конструктор с помощью его имени. Он используется для передачи метода как аргумента в другой метод или для создания лямбда-выражения. Method Reference не является самостоятельным лямбда-выражением, но является его частным случаем.

#### Что такое лямбда выражение и как его записать?
Лямбда-выражение - это анонимная функция, которая может быть передана как аргумент в другой метод или сохранена в переменной. Оно представляет собой более краткую и удобную форму записи анонимных классов, реализующих функциональные интерфейсы. Лямбда-выражение записывается как список параметров, а затем тело метода или выражение.

#### Как взаимосвязаны лямбда и функциональный интерфейс?
Чтобы объявить и использовать лямбда-выражение, основная программа разбивается на ряд этапов: 
1.Определение ссылки на функциональный интерфейс: Operationable operation;  
2.Создание лямбда-выражения: operation = (x,y) → x+y
#### К каким переменным есть доступ из лямбда-выражения?
Лямбда-выражение может использовать переменные, которые объявлены на уровне класса или метода, в котором лямбда- выражение определено.  
- Значение глобальная переменных уровня класса (Static) изменить в лямбда выражении можно.  
- Значение локальных переменных на уровне метода изменить в лямбда выражении нельзя, потому что они воспринимаются как константа (effectivelly final).  
- Инициализированные переменные интерфейса (константы). В лямбда выражении их изменить нельзя.
#### Какие переменные есть смысл подавать?
?

#### Что такое анонимный класс? Как его писать в методе синтаксически?
Анонимный класс в Java - это класс, который не имеет имени и создается непосредственно внутри метода или блока кода. Он позволяет создавать объекты на базе класса или интерфейса без явного определения отдельного класса.

Синтаксис создания анонимного класса в методе выглядит так:

```java
new КлассИлиИнтерфейс() {

  // Реализация методов класса/интерфейса

};
```
#### Чем отличается анонимный класс созданный на основе класса и интерфейса?
**1. Основанный на классе:** 
   - Может наследовать другой класс или расширять абстрактный класс.
   - Может переопределить методы родительского класса или реализовать абстрактные методы абстрактного класса.
   - Может иметь свои собственные методы и поля.
   - Может быть использован для создания объектов с различным поведением, наследуя и расширяя функциональность других классов. 
**2. Основанный на интерфейсе:**
   - Может реализовывать только один интерфейс.
   - Должен реализовать все методы из этого интерфейса.
   - Не может иметь своих собственных методов или полей.
   - Может быть использован для создания объектов, реализующих определенный интерфейс.

#### Как лямбды связаны с анонимным классом.
Лямбды связаны с анонимными классами тем, что они представляют сокращенный синтаксис для создания анонимных классов. Лямбда-выражение позволяет компактно задать функциональный интерфейс, который содержит только один абстрактный метод, и превращает его в объект-функцию.

#### Какой анонимный класс можно заменить на лямбду? 
Лямбда-выражение можно использовать вместо анонимного класса, если нужно реализовать только один абстрактный метод. Лямбда позволяет сократить код и сделать его более читаемым.

#### Расскажите про Comparator и Comparable? 
Comparator и Comparable - это интерфейсы в Java, которые используются для сравнения объектов.

#### Отличие интерфейсов Comparator и Comparable
И Comparable, и Comparator обычно используются в коллекциях Java для реализации функций сортировки. Comparable необходимо реализовать в классе, который требует сортировки, тогда как Comparator может быть реализован в другом классе или также может быть реализован с помощью лямбда-функции. 
Если нам нужна сортировка по естественному упорядочению на основе одного атрибута, то вам следует отдать предпочтение Comparable, а если требуется несколько стратегий сравнения, вместо этого рекомендуется использовать интерфейс Comparator.

#### Что такое натуральный порядок?
Натуральный порядок - это порядок, который определяется естественной, встроенной логикой объекта. Например, для чисел натуральным порядком будет возрастание: от меньшего к большему. Если объекты имеют реализацию интерфейса Comparable, то они могут быть упорядочены по натуральному порядку.

#### Что такое Стрим и для чего они нужны? В каком пакете находится Stream? 
Stream API — это средства потоковой обработки данных в функциональном стиле.  
Они не имеют ничего общего (кроме названия) с потоками ввода-вывода. Типичные применения – конвертация, переупаковка, и агрегация данных.

#### Какие бывают стримы ?
В Java есть несколько видов стримов, включая:
1. Стримы объектов (`Stream<T>`) - используются для работы с объектами.

2. Стримы примитивных типов (`IntStream, LongStream, DoubleStream`) - используются для работы с примитивными значениями int, long и double.

#### Способы получения стрима?
Существуют разные способы получения стрима:
Пустой стрим: `Stream.empty()`  <br>Стрим из List: `list.stream()`  <br>Стрим из Map: `map.entrySet().stream() ` <br>Стрим из массива: `Arrays.stream(array)`  <br>Стрим из указанных элементов: `Stream.of("1", "2", "3")`<br><br>-Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов. -Из директории на диске при помощи методов Files.list() и Files.walk()  <br>-Можно получить из строки методом chars(), будет IntStream с символами.  <br>-Можно порождать динамически, генерировать при помощи supplier.<br><br>-Итерированием какой-то функции  <br>-Можно получить диапазон чисел в виде стрима range и rangeClosed -Конкатенацией других стримов

#### Ленивая инициализация
Методы не будут выполняться пока не будет вызван терминальный метод

#### Можно ли использовать стрим повторно?
Стрим нельзя использовать повторно. После применения операций к стриму, он перестает быть доступным для дальнейшего использования. При каждом вызове операции над стримом создается новый стрим.

#### Для чего нужны параллельные стримы?
Параллельные стримы используются для обработки элементов коллекции параллельно, то есть с использованием многопоточности. Это может ускорить выполнение операций над большими объемами данных, когда каждый элемент может быть обработан независимо от других.

#### Сравнение стримов с коллекцией 
Стримы предоставляют удобный и выразительный способ обработки коллекций элементов. Они состоят из источника данных, промежуточных операций (фильтрация, отображение, сортировка и т. д.) и терминальных операций (сборка, подсчет, вывод и т. д.).

#### Из каких частей состоит использование стримов? 
Использование стримов в Java включает в себя несколько частей. Сначала вы создаете источник данных, например, коллекцию. Затем вы применяете промежуточные операции к стриму, которые фильтруют, отображают или преобразуют элементы стрима. Наконец, вы применяете терминальную операцию, которая выполняет финальное действие над элементами стрима.

#### В каком случае нужно закрывать стрим? 
Стрим нужно закрыть в случае, если он работает с внешними ресурсами, такими как файлы или сетевые соединения. В таких случаях закрытие стрима гарантирует освобождение ресурсов.

#### Терминальная операция?
Терминальная операция - это последняя операция, которую вы применяете к стриму. Она завершает выполнение стрима и может возвращать результат, результаты или совершать побочные эффекты, такие как запись в файл или вывод на консоль. Терминальные операции нужны для того, чтобы получить результаты вычислений над элементами стрима.

#### Назови все терминальные операции. Для чего терминальные операции? 
1. **forEach()** - выполняет указанное действие для каждого элемента в потоке.  
2. **forEachOrdered()** – выполняет указанное действие для каждого элемента и гаранитирует порядок.  
3. **toArray()** – преобразование стрима в массив  
4. **collect()** - собирает элементы потока данных в коллекцию  
5. **min()** – поиск минимального эл. в стриме  
6. **max()** - поиск максимального эл. в стриме  
7.  **Count()** - возвращает количество элементов  
8. **reduce()** – обьединение элементов в одно значение, к примеру операция сложения.  
9. **anyMatch()** - Проверяет, соответствует ли хотя бы один элемент стрима заданному условию.  
10. **allMatch()** - Проверяет, соответствуют ли все элементы стрима заданному условию  
11. **noneMatch()** - Проверяет, не соответствует ли ни один элемент стрима заданному условию  
12. **builder()** - Создает новый Stream.Builder, который можно использовать для создания стрима с добавлением элементов.  
13. **empty()** - Создает пустой стрим (без элементов).  
14. **findFirst()** - Возвращает первый элемент из стрима.  
15. **findAny()** -  Возвращает любой элемент из стрима.  
16. **of()** - Создает стрим со значениями, переданными в качестве аргументов.  
17. **ofNullable()** - Создает стрим, содержащий заданное значение, если оно не равно null, или пустой стрим, если значение равно null.  
18. **iterate()** - Генерирует бесконечный стрим, начиная с заданного начального значения и применяя заданный оператор на каждом следующем значении.  
19. **generate()** - Генерирует бесконечный стрим, используя поставщика для создания каждого следующего значения.  
20. **tryAdvance()** -  
22. **concat()** - Конкатенирует два стрима и возвращает новый стрим, содержащий элементы обоих стримов.  
23. **accept()** - Добавляет заданный элемент в стрим.  
24. **build()** - Создает стрим из элементов, добавленных в Stream.Builder.  
25. **add()** -  Добавляет заданный элемент в Stream.Builder.

#### Что будет если терминальной операции не будет?
Если вы не примените терминальную операцию к стриму, вы не увидите результаты вычислений и ничего не произойдет. Промежуточные операции не выполняются, пока не будет вызвана терминальная операция.

#### Две терминальные операции в одном выражении? 
В одном выражении может быть только одна терминальная операция. После выполнения терминальной операции стрим закрывается, и вы не можете снова использовать его для последующих операций.

#### Промежуточная операция?
Промежуточная операция - это операция, которая применяется к стриму после источника данных, но перед терминальной операцией. Они фильтруют, отображают, объединяют, сортируют, ограничивают или делают другие преобразования над элементами стрима. Промежуточные операции не изменяют исходный стрим, а возвращают новый стрим, который можно использовать для дальнейших операций.

#### Назови все промежуточные операции. Их предназначение.
**1. filter()** – фильтрует данные из коллекции  
**2. map()** – работает с коллекцией и возвращает другой поток.  
**3. distinct()** – возвращает стримы уникальных элементов  
**4. sorted()** – сортирает коллекцию или по натуральному порядку или прийдется задать порядок.  
**5. peek()** -  выполняет указанную операцию над каждым элементом стрима, не меняя самого стрима и не возвращая нового  
**6. limit()** - ограничивает количество элементов в потоке до заданного значения.  
**7. skip() -** используется для пропуска первых `n` элементов в стриме  
**8. takeWhile()** - спользуется для создания нового стрима, содержащего элементы из исходного стрима до тех пор, пока они удовлетворяют указанному условию.

**9. mapToInt()** – используется для преобразования стрима в примитивные значения типа (инт, лонг, дабл)      **12. flatMap()  -** позволяет обращаться к вложенным коллекциям у элемента стрима.      **13. flatMapToInt()  -** преобразует каждый элемент стрима в элементы стрима(IntStream, LongStream, DoubleStream).

#### Что возвращает промежуточная операция над стримом?
Промежуточная операция над стримом возвращает новый стрим, который содержит результаты операции над элементами исходного стрима.

#### Знать 5 примеров промежуточных операций (intermediate методы) и знать 5 примеров терминальных операций 
Промежуточные операции (intermediate методы) в Java Stream API выполняются над элементами стрима и возвращают новый стрим. Вот пять примеров промежуточных операций:

1. filter: фильтрует элементы стрима, оставляя только те, которые удовлетворяют заданному условию.
2. map: применяет заданную функцию к каждому элементу стрима, возвращая стрим с преобразованными значениями.
3. distinct: удаляет дубликаты из стрима, оставляя только уникальные элементы.
4. sorted: сортирует элементы стрима по заданному порядку.
5. limit: ограничивает количество элементов в стриме до заданного числа.

Терминальные операции (terminal methods) в Java Stream API выполняют окончательное действие над элементами стрима и возвращают конечный результат или побочные эффекты. Вот пять примеров терминальных операций:

1. forEach: применяет заданное действие (лямбда-выражение или метод) ко всем элементам стрима.
2. collect: собирает элементы стрима в определенную коллекцию или другую структуру данных.
3. count: подсчитывает количество элементов в стриме.
4. min: находит минимальный элемент в стриме на основе заданного компаратора.
5. reduce: выполняет агрегатные операции над элементами стрима, такие как сумма, произведение или конкатенация.
#### Отличие BinaryOperator от Function. 
Отличие между BinaryOperator и Function состоит в том, что BinaryOperator представляет собой функциональный интерфейс, принимающий два аргумента одного типа и возвращающий результат того же типа, тогда как Function принимает один аргумент одного типа и возвращает результат другого типа.

#### В чем разница между foreach и foreachordered
forEach и forEachOrdered похожи в том, что они выполняют заданное действие над элементами стрима. Однако разница состоит в порядке выполнения этого действия. forEach не гарантирует никакого порядка выполнения, а forEachOrdered выполняет действие в том же порядке, в котором элементы стрима были упорядочены.

#### Чем Stream.forEach отличается от Iterable.forEach?
Stream.forEach используется для выполнения заданного действия над каждым элементом стрима. Iterable.forEach используется для выполнения заданного действия над каждым элементом в итерируемой коллекции. Одна из основных различий заключается в том, что Stream.forEach позволяет применять операции стрима в цепочке, в то время как Iterable.forEach не обладает такой гибкостью.

#### Чем peek отличается от foreach?
peek и forEach также выполняют заданное действие над элементами стрима. Однако разница состоит в том, что peek является промежуточной операцией и возвращает стрим, в то время как forEach является терминальной операцией и не возвращает никаких значений.

#### Отличие метода peek от map? (оба промежуточные)
Метод peek позволяет осуществлять отладку и наблюдение за элементами стрима, не изменяя его. Метод map используется для преобразования элементов стрима посредством заданной функции и возвращает новый стрим с преобразованными значениями.

#### Разница между Map и FlatMap?
Map используется для преобразования каждого элемента стрима из одного типа в другой, возвращая стрим с преобразованными значениями. FlatMap, с другой стороны, используется для преобразования каждого элемента стрима в несколько элементов, а затем обединяет полученные стримы в один общий стрим. Это полезно, например, когда у вас есть стрим стримов и вы хотите получить один стрим со всеми элементами.

#### Разница методов .list() и walk() 
Метод .list() используется для получения списка файлов и папок в указанной директории, в то время как метод .walk() используется для получения всех файлов и папок в указанной директории и её поддиректориях.

#### Как получить стрим диапазона чисел?
Чтобы получить стрим диапазона чисел, можно использовать статические методы класса IntStream, например, IntStream.range(start, end). Этот метод создаст стрим, который будет содержать числа от start (включительно) до end (исключительно).

#### В чем разница методов range и rangeClosed? 
Методы range и rangeClosed также используются для создания стрима чисел в заданном диапазоне. Однако, range возвращает стрим, не включая верхнюю границу диапазона, в то время как rangeClosed включает верхнюю границу в стрим.

#### Можно ли конкатенировать стримы? если да то каким методом?
Да, стримы можно конкатенировать с помощью метода .concat() из класса Stream. Например, можно использовать stream1.concat(stream2) для конкатенации двух стримов stream1 и stream2.

#### Можно ли получить пустой стрим? 
Да, можно получить пустой стрим. Например, можно использовать метод Stream.empty(), который создаст пустой стрим без элементов.

#### Как получить стрим из массива? 
Для получения стрима из массива можно использовать метод Arrays.stream(array), где array - это массив элементов.

#### Что такое коллекторы? 
Коллекторы в Java - это функциональные интерфейсы, которые используются для накопления элементов стрима в какую-либо структуру данных, такую как список, множество, мапа и т.д. Коллекторы позволяют выполнять агрегатные операции над элементами стрима и получать результат в удобном виде. Например, можно использовать коллектор Collectors.toList() для сбора элементов стрима в список.

#### Objects (зачем нужен)
?
#### Метод sorted
Метод sorted: Метод sorted используется для сортировки элементов в стриме по заданному компаратору или в естественном порядке. Он возвращает отсортированный стрим.
#### В чем разница Stream и Iterator 
Stream и Iterator - это два различных интерфейса, используемых для обхода и обработки элементов в коллекции или другой структуре данных. Разница состоит в том, что Stream - это поток данных, позволяющий проводить различные операции над элементами, такие как фильтрация, сортировка и сборка, используя функциональные методы, в то время как Iterator - это более базовый интерфейс, который предоставляет методы для последовательного доступа и обхода элементов коллекции.

#### Что такое Collector? (это интерфейс).
Collector - это интерфейс, определенный в пакете java.util.stream, который используется для описания операций, накапливающих элементы из стрима в различные коллекции или структуры данных, такие как список, сет или мапа. Collector определяет методы для накопления элементов и объединения результатов работы параллельных стримов. Он позволяет создавать пользовательские операции сбора, описывая логику сбора и объединения элементов.

#### Метод Сollect? Как создать свой Collector?
- Метод Collect: Метод collect() - это метод стрима, который используется для накопления элементов стрима с помощью объекта Collector. Он принимает в качестве аргумента объект Collector и выполняет операцию накопления, указанную в этом Collector.

- Создание своего Collector: Чтобы создать свой Collector, нужно реализовать интерфейс Collector и переопределить его методы, такие как supplier(), accumulator(), combiner() и finisher(). Эти методы определяют логику сбора элементов и объединения промежуточных результатов. После этого можно использовать созданный Collector в методе collect() стрима для накопления элементов по своим правилам.

#### Класс Optional в Java
Optional - это класс, представляющий контейнер, который может содержать или не содержать значение. Он используется для предотвращения возможной ошибки NullPointerException, когда мы работаем с объектами, которые могут иметь значение null. Optional позволяет проверить, содержит ли контейнер значение, и в зависимости от этого выполнить нужные действия. Он предоставляет методы для получения значения, проверки, есть ли значение, и выполнения действий при отсутствии значения.