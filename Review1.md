1. Какая размерность у boolean?

> только `true` и `false`

2.  Переведи число X (любое) из десятичной в двоичную, и число Y (любое) из двоичной в десятичную

> можем использовать методы toBinaryString()  и parseInt() класса-обертки Integer
```java
int i = 232;
System.out.println(Integer.toBinaryString(i));
//и обратно
System.out.println(Integer.parseInt("110011",2);

```
3. Какие классы-обертки знаешь?

![](https://image2.slideserve.com/4922437/slide46-l.jpg)

4. Расскажи про pool строк и pool примитивов

> пул строк - отдельная ячейка в памяти heap.
> при создании или вызове строчной переменной происходит проверка ее наличия в памяти, если есть - то возвращает ссылку на эту строку в пуле, если нет, то создает новую
> можно проверить через двойное равно, так как он сравнивает именно ссылки

>пул примитивов создается через классы-обертки для оптимизации памяти, дабы не создавать каждый раз примитив одного и того же значения

5. Разница между String, StringBuilder и StringBuffer?

> String - объект неизменяемого класса String, потому не может быть изменен, любые преобразования создают новые объекты в памяти
> **StringBuilder** — класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет полностью идентичный API с **StringBuffer**. Единственное отличие — **StringBuilder** не синхронизирован. Это означает, что его использование в многопоточных средах есть нежелательным. Следовательно, если вы работаете с многопоточностью, Вам идеально подходит **StringBuffer**, иначе используйте **StringBuilder**, который работает намного быстрее в большинстве реализаций.

6. Какая максимальная длина массива?

> **Java** использует целое число в качестве индекса **массива**, а **максимальное** целочисленное хранилище JVM равно 2^32. таким образом, вы можете хранить в **массиве** 2 147 483 647 элементов.

7. Почему 0.1 +  0.7! = 0.8?

> все из-за того, как хранятся вещественные данные в памяти и как их воспринимает сам компьютер.
> эти неточности возникают при переводе вещественных чисел из десятичной в двоичную систему счистления и наоборот, так называемым способом плавающей запятой

8. При сложении char short какой результирующий тип получим?

> IDEA подсказывает, что это будет Integer

9. Отличие сокращенных логических операторов и полных

>отличие кратких `&&` от полных `&` заключается в том, что при кратких если первый булин = false, то остальные не проверяются
>заметно это, если сравниваются методы. При полном операторе будут в любом случае вызваны оба метода, когда как если первый метод дает false, в кратком случае второй метод вызываться не будет

10. Максимальная размерность многомерного массива

> максимально допустимая размерность многомерного массива - 255, больше JVM не вывезет

11. Все примитивные типы и их размеры
![](https://kapitanus.ru/wp-content/uploads/2019/03/%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BE%D0%B2.jpg)

12. Потери при неявных приведениях

> возможны потери точности при преобразовании целочисленных в вещественные а именно из long -> float, double, int->float

13. Какие данные мы рискуем потерять при явных приведениях?

>- Потеря десятичных значений при приведении к целым числам
>
>- Изменение значений при приведении к другим типам: Например, при приведении символа к числу мы получим числовое представление его кода в таблице символов. Также при приведении строки к числу будут использованы только цифры из строки, остальные символы будут проигнорированы.

14. Что такое Autoboxing,  unboxing и когда они происходят автоматически?

> Процесс преобразования примитивных типов в ссылочные (int->Integer) называется autoboxing (автоупаковкой), а обратный ему — unboxing (автораспаковкой). Классы-обертки являются immutable (неизменяемыми): это означает, что после создания объекта его состояние — значение поля value — не может быть изменено. Классы-обертки задекларированы как final: объекты, так сказать, read-only. Также хотелось бы упомянуть, что от этих классов невозможно наследоваться. Java автоматически делает преобразования между примитивными типами и их обертками:

> Autoboxing происходит:  

>1. При присвоении значения примитивного типа переменной соответствующего класса-обёртки.
>2. При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.
>
>Unboxing происходит:  

>1. При присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
>2. В выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
>3. При передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

15. Что такое continue и break? Расширенная версия?

> `break` полностью завершает цикл, когда как `continue` прерывает итерацию в цикле, не завершая его

16. Чем отличается метод от функции?

> На самом деле отличий нет, так как что методы, что функции являются одним и тем же. Функции что записаны вне классов называют функциями, а функции что записаны внутри классов называются методами. Поскольку **Java** это объектно ориентированный язык, то лучше говорить методы, хотя это не имеет никакого значения.

17. Что такое массив и какие на нём есть ограничения?

> _Массив — это структура данных фиксированного размера, являющаяся объектом и состоящая из ячеек, расположенных последовательно в памяти, которые могут хранить в себе значения только одного, заранее заданного типа. При этом каждая ячейка обладает адресом (порядковым номером, индексом), позволяющим получать к ней доступ._

>размер массива не может быть изменен
>максимальный размер 255
>тип данных в массиве не может быть изменен

18. Отличия for от for-each


19. Инкременты, декременты, отличия
>Инкремент — это операция, в результате которой значение переменной увеличивается на единицу. В коде она обозначается как «++", то есть двумя знаками плюса.
>Декремент — это операция, в результате которой значение переменной уменьшается на единицу. Обозначение в коде соответствует двум минусам и выглядит как «--".
>Инкремент и декремент — это унарные операции.

20. Что такое рекурсия? Недостатки и преимущества

> рекурсивные методы - методы которые вызывают сами себя
> недостаток в том, что метод может залететь в бесконечный цикл вызова самомго себя, если не обозначить точку выхода из цикла
> преимущества в простоте кода

21. Циклы
> цикл while совершает действие внутри фигурных скобок, пока в его скобках тру, когда фолз - прекращает цикл
> цикл do-while то же самое, отличие лишь в том, что когда в скобках фолз, тогда действие произойдет в фигуных скобках единожды и завершит цикл
> цикл for итерирует до тех пор пока не достигнет условия выхода из цикла

22. Условные операторы
>if-else - если в скобках тру, то выполняется тело, которое после if, если фолз, спускаемся к тело else, а если и там не совпадает, то код спускается ниже
>switch() - позволяет сравнивать значения в скобках с кейсами. Для прерывания сравнивания используется break

23. Неизменяемые типы

> 
