## Spring Boot
##### Основные преимущества 
использования Spring Boot:
- Автоконфигурация: Spring Boot автоматически настраивает приложение на основе добавленных зависимостей.
- Встроенные серверы: Spring Boot имеет встроенные серверы приложений, такие как Tomcat и Jetty, что позволяет легко развертывать и тестировать приложения.
- Простота использования: Spring Boot предлагает аннотации и классы начальной загрузки для упрощения разработки.
- Spring Boot Starters: предоставляют готовые решения для интеграции с различными технологиями.
- Продуктивность: Spring Boot упрощает процесс разработки, что увеличивает производительность разработчика [geeksforgeeks.org](https://www.geeksforgeeks.org/spring-boot-auto-configuration/).

##### Автоконфигурация Spring Boot:
Автоконфигурация в Spring Boot представляет собой механизм, который настраивает приложение на основе зависимостей, указанных в файле pom.xml. Это достигается с помощью аннотации `@EnableAutoConfiguration`, которая автоматически настраивает ApplicationContext Spring.
Внутри процесса автоконфигурации Spring Boot использует аннотации `@Conditional`, `@ConditionalOnClass`, `@ConditionalOnProperty` и другие для определения, должны ли определенные конфигурации быть активными или нет. Эти аннотации указывают, что конфигурация должна быть применена только при выполнении определенных условий [dzone.com](https://dzone.com/articles/how-springboot-autoconfiguration-magic-works).

##### Ключевые аннотации и конфигурации в Spring Boot:
- `@SpringBootApplication`: Это удобная аннотация, которая включает в себя `@Configuration`, `@EnableAutoConfiguration` и `@ComponentScan`.
- `@EnableAutoConfiguration`: Эта аннотация включает автоматическую конфигурацию Spring Boot.
- `@ConfigurationProperties`: Эта аннотация связывает свойства из файла свойств Spring с объектом Java [baeldung.com](https://www.baeldung.com/configuration-properties-in-spring-boot).
- `@Conditional`, `@ConditionalOnClass`, `@ConditionalOnProperty` и другие: Эти аннотации используются в автоконфигурации для определения, должны ли определенные конфигурации быть активными или нет [dzone.com](https://dzone.com/articles/how-springboot-autoconfiguration-magic-works).

##### Аннотация `@EnableAutoConfiguration`:
Аннотация `@EnableAutoConfiguration` включает автоматическую конфигурацию Spring Boot. Она автоматически настраивает ApplicationContext Spring, сканируя классы в classpath и регистрируя соответствующие бины [geeksforgeeks.org](https://www.geeksforgeeks.org/spring-boot-auto-configuration/).

##### Сканирование компонентов в Spring Boot:
Spring Boot автоматически выполняет сканирование компонентов в том же пакете, где находится основной класс приложения (класс, аннотированный с `@SpringBootApplication`). Если ваши компоненты находятся в других пакетах, вам нужно указать эти пакеты с помощью аннотации `@ComponentScan` [baeldung.com](https://www.baeldung.com/spring-component-annotation).




##### Что такое Spring Boot Starter и какие преимущества он может предложить разработчикам?

Spring Boot Starter - это набор удобных зависимостей, которые можно добавить в свой проект для упрощения конфигурации и ускорения разработки. Эти "стартеры" делают предположения о том, что вам нужно для быстрого старта разработки, добавляя библиотеки и настройки по умолчанию, которые обычно используются в типичных Spring Boot проектах.

Преимущества использования Spring Boot Starter включают:

- Упрощение зависимостей: Вам не нужно вручную добавлять каждую зависимость, которая вам нужна. Вместо этого, вы просто добавляете стартер, и он автоматически включает все необходимые библиотеки.
- Быстрый старт: Стартеры позволяют быстро начать работу над новым проектом, уменьшая количество кода и конфигурации, которые вам нужно написать перед началом работы.
- Лучшие практики: Стартеры следуют "мнение образующему" подходу Spring Boot, предоставляя разумные настройки по умолчанию и структуру проекта, которые соответствуют лучшим практикам сообщества Spring.

##### Как можно настроить уровень логирования в Spring Boot?

Уровень логирования в Spring Boot можно настроить несколькими способами. Один из способов - через файл `application.properties` или `application.yml`. Вы можете указать уровень логирования для всего приложения или для конкретных пакетов, указав `logging.level.root` или `logging.level.[название вашего пакета]` соответственно. Например:

`logging.level.root=WARN logging.level.com.baeldung=TRACE`

Вы также можете установить уровень логирования через переменные среды или аргументы командной строки. Для этого используйте параметр `-Dlogging.level.[название вашего пакета]`. Например:

`-Dlogging.level.org.springframework=TRACE  -Dlogging.level.com.baeldung=TRACE`


Если вы используете Maven или Gradle, вы можете определить настройки логирования через командную строку:

`mvn spring-boot:run -Dspring-boot.run.arguments=--logging.level.org.springframework=TRACE,--logging.level.com.baeldung=TRACE`

Наконец, вы можете изменить уровень логирования постоянно, используя файл конфигурации вашего фреймворка логирования. Spring Boot Starter по умолчанию использует Logback. Вот как определить фрагмент файла конфигурации Logback, в котором мы устанавливаем уровень для двух отдельных пакетов:

`<logger name="org.springframework" level="INFO" /> <logger name="com.baeldung" level="INFO" />`

## Spring Rest

##### **Что такое REST и как он отличается от RESTful?**

REST (Representational State Transfer) - это архитектурный стиль, который определяет набор ограничений, используемых при создании веб-сервисов. Этот стиль был разработан Роем Филдингом в его докторской диссертации в 2000 году. REST использует стандартные HTTP-методы и основан на ресурсах, идентифицируемых URL. Важным аспектом REST является его безсостояние, что означает, что каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для выполнения запроса [positiwise.com](https://positiwise.com/blog/difference-between-restapi-restful-api).

RESTful API - это API, который следует принципам REST. "RESTful" означает, что API создан с использованием принципов и стандартов, определенных в REST. В общем контексте, термины "REST" и "RESTful" часто используются взаимозаменяемо [positiwise.com](https://positiwise.com/blog/difference-between-restapi-restful-api).

##### **Что подразумевается под термином "ресурс" в контексте REST?**

Ресурс в контексте REST - это любой объект данных, который может быть доступен для клиента. Ресурс может представлять собой объект или набор объектов, и каждый ресурс имеет свой собственный URL (Uniform Resource Identifier), который используется для его идентификации. Важно отметить, что в REST ресурс и его представление разделены. Ресурс определяет концепцию или объект данных, а представление ресурса - это способ, которым этот ресурс представлен клиенту, например, в формате JSON или XML [ibm.com](https://www.ibm.com/topics/rest-apis).

##### **Каковы основные HTTP методы, используемые в REST?**

Основные HTTP-методы, используемые в REST, включают:

- GET: Используется для получения информации о ресурсе.
- POST: Используется для создания нового ресурса.
- PUT: Используется для обновления существующего ресурса.
- DELETE: Используется для удаления ресурса.

Эти методы соответствуют операциям CRUD (Create, Read, Update, Delete) в базе данных [w3schools.in](https://www.w3schools.in/restful-web-services/rest-methods).

##### **Можете ли вы объяснить значение идемпотентности в контексте REST?**

Идемпотентность - это свойство определенных операций в математике и компьютерных науках, которое означает, что любое количество повторяющихся вызовов такой операции не изменит результат после первого вызова. В контексте REST и HTTP, идемпотентность означает, что повторный вызов одного и того же запроса будет производить один и тот же результат. Например, HTTP методы GET, PUT и DELETE считаются идемпотентными, поскольку они могут быть повторены несколько раз без различия в результате [restcookbook.com](https://restcookbook.com/Miscellaneous/rest-and-http/).

##### **Что такое HttpMessageConverter и как он используется в Spring REST?**

`HttpMessageConverter` конвертирует запрос в объект и наоборот.
Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.
В этом случае `DispatcherServlet` не использует Model и View.
В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.

Список конвертеров:
    - `BufferedImageHttpMessageConverter` — конвертирует `BufferedImage` в(из) код изображения.
    - `Jaxb2RootElementHttpMessageConverter` — конвертирует xml в(из) объект, помеченный jaxb2 аннотациями. Регистрируется, если jaxb2 находится в classpath.
    - `MappingJackson2HttpMessageConverter` — конвертирует JSON в(из) объект. Регистрируется, если Jackson 2 находится в classpath.
    - `StringHttpMessageConverter` — конвертирует все медиа-файлы в text/plain.

##### Как работают аннотации @RestController, @ResponseBody, @RequestMapping, @GetMapping, @PostMapping, @DeleteMapping, @RequestParam, @PathVariable и @ResponseStatus?

**Аннотации**

- `@RestController`: Это аннотация, которая указывает, что класс является контроллером RESTful. Она является сокращением для `@Controller` и `@ResponseBody`. Это означает, что любые данные, возвращаемые методами в этом классе, будут автоматически преобразованы в представление и отправлены обратно клиенту [stackabuse.com](https://stackabuse.com/controller-and-restcontroller-annotations-in-spring-boot/).

- `@ResponseBody`: Эта аннотация указывает, что возвращаемое значение метода должно быть преобразовано в представление и отправлено обратно клиенту [baeldung.com](https://www.baeldung.com/spring-request-response-body).

- `@RequestMapping`: Эта аннотация используется для указания, что метод или класс должен обрабатывать запросы к определенному URL-адресу. Она может быть использована для указания HTTP-методов (GET, POST, PUT, DELETE и т.д.) [baeldung.com](https://www.baeldung.com/spring-requestmapping)

- `@GetMapping`, `@PostMapping`, `@DeleteMapping`: Это упрощенные версии аннотации `@RequestMapping`, которые указывают, что метод должен обрабатывать GET, POST или DELETE запросы соответственно [howtodoinjava.com](https://howtodoinjava.com/spring-mvc/controller-getmapping-postmapping/).

- `@RequestParam`: Эта аннотация используется для связывания параметров запроса с параметрами метода [baeldung.com](https://www.baeldung.com/spring-request-param).

- `@PathVariable`: Эта аннотация используется для связывания переменных пути с параметрами метода [baeldung.com](https://www.baeldung.com/spring-requestmapping).

- `@ResponseStatus`: Эта аннотация используется для указания статуса HTTP, который должен быть возвращен клиенту [spring.io](https://spring.io/guides/tutorials/rest/).

##### ResponseEntity

Класс ResponseEntity представляет полный HTTP-ответ: состояние, заголовки и тело. Он используется для более тонкого контроля над ответом, чем просто возвращение объекта из метода контроллера. Например, вы можете установить статус ответа, добавить заголовки или возвратить данные в определенном формате [spring.io](https://spring.io/guides/tutorials/rest/).


##### RequestBody

Аннотация `@RequestBody` используется для связывания тела HTTP-запроса с параметром метода. Она обычно используется в методах POST и PUT, когда вы хотите получить данные из тела запроса. Например, если вы отправляете JSON в теле запроса, вы можете использовать `@RequestBody` для преобразования этого JSON в объект Java [baeldung.com](https://www.baeldung.com/spring-request-response-body).
##### RestTemplate
**RestTemplate** - это класс в Spring, который используется для отправки HTTP запросов. Он предоставляет синхронный и блокирующий подход к отправке HTTP запросов. Это означает, что когда вы делаете HTTP запрос, вам нужно дождаться ответа, прежде чем продолжить выполнение кода. Однако, начиная с версии 5.0, RestTemplate устарел и будет поддерживаться только в режиме обслуживания, без добавления новых функций [stackoverflow.com](https://stackoverflow.com/questions/47974757/webclient-vs-resttemplate).

Вместо RestTemplate, Spring предлагает WebClient, который является более современным и эффективным HTTP клиентом. WebClient предоставляет как традиционный синхронный API, так и эффективный неблокирующий и асинхронный подход. WebClient является частью Spring WebFlux и поддерживает обработку как синхронных, так и асинхронных запросов [baeldung.com](https://www.baeldung.com/spring-webclient-resttemplate), [howtodoinjava.com](https://howtodoinjava.com/spring-webflux/webclient-vs-resttemplate/), [baeldung.com](https://www.baeldung.com/rest-template).

##### RestController и Controller – разница
**@RestController** и **@Controller** - это аннотации в Spring, которые используются для определения контроллеров. Основное отличие между ними заключается в том, как они обрабатывают возвращаемые объекты.

`@Controller` - это аннотация, которая используется для традиционных Spring контроллеров. Когда метод контроллера возвращает объект, он автоматически конвертируется в представление (view) для отображения пользователю.

`@RestController` - это аннотация, которая является специальной версией `@Controller`. Она включает в себя аннотации `@Controller` и `@ResponseBody`, что упрощает реализацию контроллера. Когда метод контроллера возвращает объект, он автоматически конвертируется в JSON или XML и отправляется обратно клиенту. Это делает `@RestController` идеальным для создания RESTful веб-сервисов [baeldung.com](https://www.baeldung.com/spring-controller-vs-restcontroller).

##### **6 принципов RESTful**:

- Клиент-сервер: Клиент и сервер работают независимо друг от друга. Это позволяет клиенту и серверу развиваться независимо друг от друга.
- Без сохранения состояния: Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса. Сервер не должен хранить информацию о состоянии клиента между запросами.
- Кэширование: Клиенты могут кэшировать ответы. Это позволяет уменьшить нагрузку на сервер и увеличить производительность.
- Унифицированный интерфейс: Все ресурсы идентифицируются по унифицированному имя ресурса. Это упрощает взаимодействие между клиентами и серверами.
- Семантика: Методы HTTP (GET, POST, PUT, DELETE и т.д.) используются для описания действий над ресурсами.
- Гипермедиа: Серверы должны возвращать информацию о том, как обрабатывать полученные данные, предоставляя ссылки на другие ресурсы.


## **Spring Security**

##### Что такое авторизация и аутентификация в контексте Spring Security?
 Аутентификация и авторизация в контексте Spring Security относятся к двум ключевым аспектам обеспечения безопасности веб-приложений.
    - Аутентификация - это процесс проверки идентификации пользователя. Это обычно включает в себя ввод имени пользователя и пароля, которые затем сравниваются с записанными в базе данных. Если они совпадают, пользователь считается аутентифицированным [dev.to](https://dev.to/marcobehler/spring-security-authentication-and-authorization-in-depth-m9g).
    - Авторизация - это процесс определения, какие ресурсы или операции доступны для аутентифицированного пользователя. Это может включать в себя проверку ролей пользователя, его уровня доступа и других атрибутов безопасности [dev.to](https://dev.to/marcobehler/spring-security-authentication-and-authorization-in-depth-m9g).

##### Что представляют собой объекты Principal, Authorities, Authentication в Spring Security?
В контексте Spring Security, объекты Principal, Authorities и Authentication имеют следующие функции:
    - Principal: Этот интерфейс представляет аутентифицированного пользователя. Он обычно используется для получения информации о пользователе, такой как имя пользователя или идентификатор [baeldung.com](https://www.baeldung.com/spring-security-oauth-principal-authorities-extractor).
    - Authorities: Это коллекция ролей или привилегий, которые имеют пользователи. Обычно они представлены в виде объектов GrantedAuthority [docs.spring.io](https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/authorization.html).
    - Authentication: Этот интерфейс представляет процесс аутентификации. Он содержит информацию о пользователе (Principal), его учетных данных и его авторизация (Authorities) [docs.spring.io](https://docs.spring.io/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html).

##### Как можно добавить защиту к контроллеру в Spring? 
В Spring Security есть несколько способов добавить защиту к контроллеру:
    - Использование аннотаций: Вы можете использовать аннотации, такие как @PreAuthorize и @PostAuthorize, чтобы контролировать доступ к методам контроллера. Эти аннотации позволяют вам использовать выражения на основе Spring EL для определения условий доступа [docs.spring.io](https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/authorization.html).
    - Использование конфигурации Spring Security: Вы можете настроить Spring Security для защиты определенных URL-адресов или методов контроллера. Это обычно делается в классе конфигурации Spring Security, который расширяет WebSecurityConfigurerAdapter или реализует WebSecurityConfigurer [dev.to](https://dev.to/marcobehler/spring-security-authentication-and-authorization-in-depth-m9g).

Например, вы можете использовать следующий код для защиты определенного метода контроллера:

```java
  @Configuration
  @EnableWebSecurity
  public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http
              .authorizeRequests()
                 .antMatchers("/secure").authenticated()
                 .anyRequest().permitAll();
      }
  }
```



## Микросервисы

##### Объясните понятие API и его назначение в разработке программного обеспечения.

**API (Application Programming Interface)** - это набор правил и протоколов, которые определяют, как программные компоненты должны взаимодействовать друг с другом. В контексте разработки программного обеспечения, API предоставляет набор функций и процедур, которые позволяют программам взаимодействовать друг с другом. Это может включать в себя функции для создания, чтения, обновления и удаления данных, а также другие операции, специфичные для приложения или сервиса.

##### Что такое API Gateway и каковы его преимущества?

**API Gateway** - это сервер, который служит точкой входа для всех клиентских запросов к сервисам. Он обрабатывает все входящие запросы и направляет их к соответствующим сервисам. Преимущества API Gateway включают:
    - Централизованное управление: API Gateway позволяет централизовать управление всеми сервисами, что упрощает их масштабирование и обслуживание.
    - Безопасность: API Gateway может предоставлять функции безопасности, такие как аутентификация и авторизация, для всех входящих запросов.
    - Оптимизация производительности: API Gateway может кэшировать ответы от сервисов, уменьшая нагрузку на сервисы и улучшая время ответа.

##### В каких случаях полезно использовать Keycloak?

**Keycloak** - это открытый продукт для управления идентификацией и доступом, который предоставляет функции аутентификации и авторизации. Он полезен в следующих случаях:

- Управление идентификацией и доступом: Keycloak предоставляет функции для управления идентификацией пользователей и контроля доступа к ресурсам.
- Интеграция с OAuth2 и OpenID Connect: Keycloak поддерживает эти стандарты протокола, что позволяет интегрировать его с другими системами, использующими эти протоколы.
- Управление ролями и разрешениями: Keycloak позволяет определять роли и разрешения для пользователей, что упрощает управление доступом к ресурсам.

##### Можете ли вы объяснить стандарты Oauth2 и Openid на высоком уровне?

**OAuth2 и OpenID Connect** - это протоколы, которые определяют, как клиенты могут получить доступ к ресурсам, защищенным сервером.

- **OAuth2** - это протокол, который позволяет клиентам получать доступ к защищенным ресурсам от имени пользователя. Это делается путем получения токена доступа от сервера, который затем используется клиентом для доступа к ресурсам.
- **OpenID Connect** - это протокол, который расширяет OAuth2, добавляя функции аутентификации. Это позволяет клиентам убедиться, что токен доступа, который они получают, действительно принадлежит пользователю.

##### Где и для чего обычно используется JWT?
**JWT (JSON Web Token)** - это открытый стандарт, который определяет способ безопасной передачи информации между двумя сторонами в виде JSON-объекта. JWT обычно используется для аутентификации и передачи информации о пользователе между клиентом и сервером. Это может быть полезно в следующих случаях:

- **Аутентификация**: JWT может использоваться для аутентификации пользователей, когда сервер может проверить подпись токена и убедиться, что он действительно был выпущен доверенным сервером.
- **Передача информации**: JWT может содержать информацию о пользователе, которая может быть использована сервером для принятия решений о доступе к ресурсам.
- **Сессии**: JWT может использоваться для управления сессиями, когда сервер может отслеживать состояние пользователя, не требуя от него постоянного подключения к серверу.



##### Опишите принципы многослойной архитектуры.

Многослойная архитектура — это подход к проектированию программного обеспечения, который разделяет приложение на отдельные слои. Каждый слой имеет свою специфическую роль и обеспечивает определенный уровень абстракции. Обычно в многослойной архитектуре используются следующие слои:
    - **Представление** (Presentation Layer): Этот слой отвечает за взаимодействие с пользователем. Он может включать в себя веб-интерфейс, мобильное приложение или другие пользовательские интерфейсы.
    - **Бизнес-логика** (Business Logic Layer): Этот слой содержит основную логику приложения и обрабатывает бизнес-правила.
    - **Данные** (Data Layer): Этот слой отвечает за хранение и извлечение данных. Он может включать в себя базы данных, файловые системы и другие механизмы хранения данных.

##### В чем отличия между resource-server и authorization-server?

Resource Server и Authorization Server — это два ключевых компонента в архитектуре OAuth 2.0.
    - **Resource Server** — это сервер, который хранит и обрабатывает ресурсы, доступ к которым контролируется через OAuth 2.0. Resource Server проверяет токены доступа, предоставленные Authorization Server, чтобы определить, имеет ли клиент право доступа к определенному ресурсу [docs.spring.io](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html).
    - **Authorization Server** — это сервер, который выдает токены доступа после того, как клиент прошел процесс аутентификации и авторизации. Authorization Server также отвечает за обновление токенов доступа [spring.io](https://spring.io/projects/spring-authorization-server/).

##### Как различаются интеграционные тесты и модульные тесты в контексте Spring (например, @SpringBootTest vs @ExtendWith)?

В контексте Spring, интеграционные тесты и модульные тесты имеют разные цели и подходы:
    - **Модульные тесты** обычно фокусируются на тестировании отдельных компонентов или классов в изоляции. Они используют аннотацию `@ExtendWith` для подключения различных расширений, таких как `MockitoExtension` для создания моков и `SpringExtension` для подключения контекста Spring.
    - **Интеграционные тесты**, с другой стороны, фокусируются на тестировании взаимодействия между компонентами или модулями. Они используют аннотацию `@SpringBootTest` для запуска полного контекста Spring и `@WebMvcTest` для тестирования контроллеров MVC.

##### Что такое компонентное тестирование? Приведите примеры (@WebMvcTest, @DataJpaTest).

Компонентное тестирование — это подход к тестированию, в котором тестируются отдельные компоненты системы, включая их взаимодействие с другими компонентами. В контексте Spring, компонентное тестирование может включать в себя следующие аннотации:
    - `@WebMvcTest` — используется для тестирования контроллеров MVC. Он автоматически настраивает контекст Spring, включая конфигурацию Spring MVC и контроллеры, которые требуются для тестирования.
    - `@DataJpaTest` — используется для тестирования слоя доступа к данным. Он автоматически настраивает контекст Spring, включая конфигурацию Spring Data JPA и репозитории, которые требуются для тестирования.

##### Объясните, что такое mock и spy в контексте тестирования.

В контексте тестирования, "mock" и "spy" относятся к различным типам "test doubles" (двойников для тестирования).
    - "Mock" в Mockito представляет собой обычный мок в других фреймворках для мокирования (позволяет заменять вызовы методов на конкретные значения). В моке все методы по умолчанию не делают ничего, если не указано иначе. Это означает, что если метод является void, то он ничего не делает при вызове, а если метод возвращает значение, он может возвращать null, пустое значение или значение по умолчанию [javapointers.com](https://javapointers.com/java/unit-test/difference-between-spy-and-mock-in-mockito/).
    - "Spy" в Mockito представляет собой частичный мок в других фреймворках для мокирования (часть объекта будет заменена на мок, а другая часть будет использовать реальные вызовы методов). В spy, если вы не заменяете метод, он вызывает реальное поведение метода. Если вы хотите изменить и заменить метод, то вам нужно заменить его [stackoverflow.com](https://stackoverflow.com/questions/28295625/mockito-spy-vs-mock).

##### Объяснить аннотации @Mock, @MockBean, @BeforeEach, @AfterEach, @WithMockUser

Аннотации `@Mock`, `@MockBean`, `@BeforeEach`, `@AfterEach`, `@WithMockUser` используются в Mockito и Spring для настройки тестов.
    - `@Mock` используется для создания мока объекта. Этот мок заменяет все методы объекта на заглушки, которые ничего не делают, если не указано иначе [stackoverflow.com](https://stackoverflow.com/questions/29590621/mock-instance-is-null-after-mock-annotation).
    - `@MockBean` используется для создания мока Spring Bean. Это полезно, когда вы хотите заменить определенный бин на мок в контексте Spring.
    - `@BeforeEach` и `@AfterEach` являются аннотациями JUnit 5, которые используются для указания методов, которые должны быть выполнены перед каждым тестом и после каждого теста соответственно.
    - `@WithMockUser` используется для указания, что тест должен быть выполнен с определенным пользователем. Это полезно, когда вы хотите проверить поведение системы в контексте определенного пользователя.
